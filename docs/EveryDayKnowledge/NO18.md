# 每天一个小知识点
## 第十八天 
---

## 攻击类型
XSS攻击: 跨站脚本攻击，是一种代码注入攻击。攻击者把可执行的恶意脚本注入搭配页面中,使之在用户的浏览器上运行,从而盗取用户的信息如 cookie 等。  
解决方案：   
1、对需要插入到 HTML 中的代码做好充分的转义  
2、使用 CSP，建立一个白名单，告诉浏览器哪些外部资源可以加载和执行,从而防止恶意代码的注入攻击 

CSRF攻击: 跨站请求伪造攻击,攻击者诱导用户进入一个第三方网站,然后该网站向被攻击网站发送跨站请求,如果用户在被攻击网站中保存了登录状态,那么攻击者就可以利用这个登录状态,绕过后台的用户验证,冒充用户向服务器执行一些操作。比如攻击者可以通过在输入留言框内输入可发送请求的代码，留言放到网站上，这样每个人进入这个网站的时候都会执行这行代码并发送携带自己的cookie账号密码等关键信息的请求，这样攻击者就能拿到用户的信息伪造拿去登录了  
解决方案：  
1.同源检测  
2.使用 CSRF Token 进行验证  
3.限制 cookie 不能作为被第三方使用
## 实现一个countFn,接受一个函数作为参数,返回一个新函数,具备调用计数器功能
1、proxy  
proxy中的函数调用操作的捕捉器是apply,因此我们需要有一个计数的属性count,然后重写apply中的内容,在这做count的增量就可以了,这样每次调用testCount(),都会执行apply里的内容.至于count,不论放在handler这个对象还是放在countFn这个函数里都可以
```js
function countFn(fn){
  var count = 0
  let handler = {
    // count: 0
    apply: function(target, that, agrs) {
      console.log(++count)
      target.apply(that, args)
    }
  }
  return new Proxy(fn, handler)
}
function test () {
  console.log('test')
  console.log(this)
}
function test2 () {
  console.log('test2')
}
const testCount = countFn(test)
const test2Count = countFn(test2)
testCount() // 1 'test'
testCount() // 2 'test'
testCount() // 3 'test'

test2Count() // 1 'test2'
test2Count() // 2 'test2'
test2Count() // 3 'test2'
```
2、闭包  
```js
function countFn(fn) {
  var count = 0
  return function() {
    count++
    fn.call(this,...arguments)
    console.log(count)
  }
}

function fn1(test) {
  console.log('test1', test)
}
function fn2(test) {
  console.log('test2', test)
}

var test1 = countFn(fn1)
var test2 = countFn(fn2)
test1('111')//test1 111 1
test2('111')//test2 111 1
test1('222')//test1 222 2
test2('222')//test2 222 2
test2('333')//test2 333 3
test1('333')//test1 333 3

```
3、放在原型链上
```js
Function.prototype.countFn=function(){
    var count=0;
    var fn=this
    return function(){
        count++
        fn.call(this,...arguments)
        console.log(count)
    }
}
var test1= fn1.countFn()
var test2= fn2.countFn()
test1('111')//test1 111 1
test2('111')//test2 111 1
test1('222')//test1 222 2
test2('222')//test2 222 2
test2('333')//test2 333 3
test1('333')//test1 333 3
```
## Object.creat(null)和直接使用字面量{}创建空对象有什么区别和好处

## 手写Promise.then如何保证后一个then里的方法在前一个then结束之后再执行？
