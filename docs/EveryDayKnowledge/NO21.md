# 每天一个小知识点
## 第二十一天 
---

## 1、js严格模式下有哪些不用  
1、严格模式下不能使用with语句  
2、严格模式下所有变量都必须声明  
3、严格模式下,函数如果作为函数被调用,其this值为undefined  
4、严格模式下,给不可写的属性赋值或者尝试在不可扩展的对象上创建新属性会抛出TypeError  
5、严格模式下eval不再为上层范围引入新变量  
6、严格模式下要求函数的参数名唯一  
7、严格模式下禁止删除申明变量  
8、严格模式下不允许使用八进制整数字面量  
9、严格模式下标识符eval、arguments被当做关键字,不允许修改他们的值  
10、严格模式下调用栈的能力是受限的
## 2、递归和迭代的区别,各自的优缺点
（一）定义：  
**递归**: 递归常被用来描述以自相似方法重复事物的过程，在数学和开发中，指的是在函数定义中使用函数自身的方法；递归实际上不断地深层调用函数，直到函数有返回才会逐层的返回，递归是**用栈机制实现的，每深入一层，都要占去一块栈数据区域，因此，递归涉及到运行时的堆栈开销（参数必须压入堆栈保存，直到该层函数调用返回为止）**，所以有可能导致堆栈溢出的错误；但是递归编程所体现的思想正是人们追求简洁、将问题交给计算机，以及将大问题分解为相同小问题从而解决大问题的动机。递归，还有个尾调用优化，**尾调用优化就是如果本次调用的返回值，是子调用的返回值的话，本次调用就可以直接出栈了，不需要进行嵌套**。就可以实现栈深为1的递归调用。递归从字面可以其理解为重复“递推”和“回归”的过程（递推：层层推进，分解问题；回归：层层回归，返回较大问题的解）  

**迭代**: 是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。**迭代是顺序的，不涉及调用栈操作，前面的代码不会被后面代码影响，递归是涉及到调用栈的，遵循先进后出后进先出原则，前面的函数调用会阻塞，要在后面的调用返回值后才能继续执行，所以迭代的好处就是栈深小，**但是代码逻辑不够清晰，递归则是嵌套调用多，栈深比较大，容易爆栈，但代码结构会比较简洁，速度的话还是迭代快。迭代大部分时候需要人为的对问题进行剖析，分析问题的规律所在，将问题转变为一次次的迭代来逼近答案。迭代不像递归那样对堆栈有一定的要求，另外一旦问题剖析完毕，就可以很容易的通过循环加以实现。迭代的效率高，但却不太容易理解，当遇到数据结构的设计时，比如图表、二叉树、网格等问题时，使用就比较困难，而是用递归就能省掉人工思考解法的过程，只需要不断的将问题分解直到返回就可以了。  
（二）同异点：  
相同点：递归和迭代都是循环的一种。

不同点：  
（1）程序结构不同：递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。  
（2）算法结束方式不同：递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。  
（3）效率不同：在循环的次数较大的时候，迭代的效率明显高于递归  
（4）运行过程不同，如果是循环迭代的话，这个整个就在主函数的或者在调用函数的栈空间里面，如果是递归的话，它会不断的申请函数调用的栈空间，在计算的过程中，计算一个结果，退一层栈，递归过程，在调用的时候有可能会出现栈的溢出。  
（5）理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。  
（三）优缺点  
递归  
优点: 大问题转化为小问题，可以减少代码量，同时代码精简，可读性好。  
缺点: 递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。  
迭代  
优点: 就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销。  
缺点: 就是代码不如递归简洁

## 3、对cookie、session、token的理解
cookie由服务器生成，发送给浏览器，浏览器把cookie以key value形式保存到某个目录下的文本文件内，下一次请求同网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。  

session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，一般都默认采用cookie的方式。服务器使用 session 把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失  

在web领域基于token的身份验证随处可见。在大多数使用web api的互联网公司中，token是多用户下处理认证的最佳方式。基于token的身份验证是无状态的，我们不将用户信息存在服务器或session中。这种概念解决了在服务端存储信息时的许多问题。

## 4、在map中和在for中调用异步函数的区别
区别:  
map会把执行同步操作执行完,就返回,之后再一次一次的执行异步任务  
for循环是等待异步返回结果后再进入下一个循环  
map函数的原理：  
循环数组,把数组每一项的值,传给回调函数  
将回调函数处理后的结果push到一个新的数组  
返回新数组  
map函数是同步执行的,循环每一项,到给新数组赋值都是同步操作
## 5、实现函数柯里化
// TODO 未补全
```js
 function curry(func) {
   //此处补全
 }
 function sum(...args) {
   return args.reduce((a, b) => a + b)
 }

 let curriedSum = curry(sum);

 alert(curriedSum(1, 2, 3)); // 6
 alert(curriedSum(1)(2, 3, 4)); // 10
 alert(curriedSum(1)(2)); // 3

```