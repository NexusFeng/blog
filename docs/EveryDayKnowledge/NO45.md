# 每天一个小知识点
## 第四十五天 
---

## 输出
```js
function foo() {
  console.log(this.a)
}
var obj = {a:1}
var a = 2
foo()// undefined
foo.call(obj)//1
foo().call(obj)//TypeError: Cannot read property 'call' of undefined
// 会先执行foo()
function foo() {
    return function(){console.log(1)}
  }
  var obj = {a:1}
  var a = 2
  foo().call(obj)// 1
```
## webpack中context.require()

## 401和403的区别,301和307区别
- 401,用户没有鉴权,常见场景为用户未登录
- 403,用户没有权限,常见场景为用户登录了没有权限
- 301,资源永久重定向
- 307,资源临时重定向,遵守浏览器规则,不会从POST变为GET
## css画三角形有哪几种
```css
div{
  width: 0;
  height: 0;
  border-top: 50px solid red;
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;
}
```
## 继承,除了class以外,还有那些,各自的优缺点
1.原型链继承
```js
function Parent(){
  this.name = 'feng'
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child {

}
Child.prototype = new Parent()
let child1 = new Child()
```
优点： 
- 易于实现,父类新增的方法子类都能访问到
缺点：
- 引用类型的属性和方法被所有实例共享
- 不能多继承,原型一次只能被一个实例更改
- 创建子类时,不能向父类传递参数

2.借用构造函数(经典继承)
```js
function Parent() {
  this.name = 'feng'
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child() {
  Parent.call(this)
}
let child = new Child()
```
优点：
- 创建子类时可以向父类传递参数
- 可以继承多个父类,绑定多个call
- 引用类型的属性和方法不被所有实例影响
缺点：
- 子类不能继承父类原型上的方法和属性
3.组合继承
```js
function Parent() {
  this.name = 'feng'
}
Parent.prototype.getName = function () {
  console.log(this.name)
}
function Child() {
  Parent.call(this)
}
Child.prototype = new Parent()

```
## `[1,0,2,0,3,12]=>[1,2,3,12,0,0]`把0往后排,然后非0数字顺序不变,不使用额外空间