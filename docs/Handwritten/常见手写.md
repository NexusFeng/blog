## `Object.create`

实现思路: 将传入的对象作为原型对象

```js
function create(obj) {
  function fn() {}
  fn.prototype = obj;
  return new fn();
}
```

## `instanceof`

实现思路:

- 获取右侧对象的原型对象
- 循环遍历左侧对象的原型与右侧相对比

```js
function myInstanceof(left, right) {
  left = Object.getPrototypeOf(left);
  right = right.prototype;
  while (true) {
    if (!left) return false;
    if (left === right) return true;
    left = Object.getPrototypeOf(left);
  }
}
```

## `new`模拟实现

实现思路:

- 新建一个对象
- 利用`Object.create`创建原型链关系
- 利用`.call`方法执行构造函数,`this`是这个新建的对象
- 判断返回值类型,如果是值类型,返回这个对象,如果是引用类型,返回这个引用类型

```js
function myNew(fn, ...args) {
  let newObj = Object.create(fn.prototype);
  let res = fn.call(newObj, ...args);
  return res && (typeof res === 'function' || typeof res === 'object')
    ? res
    : neObj;
}
```

## 数组拍平

- 写一个 js 函数,实现数组扁平化,只减少一级嵌套
- 输入`[1,[2,[3]],4]`,输出`[1,2,[3],4]`

```ts
// push
function flatten1(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      item.forEach((n) => res.push(n));
    } else {
      res.push(item);
    }
  });

  return res;
}
```

```ts
// concat
function flatten2(arr: any[]): any[] {
  let res: any[] = [];

  arr.forEach((item) => {
    res = res.concat(item);
  });
  return res;
}
```

## 深度拍平

```ts
function flattenDeep(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep(item);
      flatItem.forEach((n) => res.push(n));
    } else {
      res.push(item);
    }
  });

  return res;
}
```

```ts
function flattenDeep(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep(item);
      res = res.concat(flatItem);
    } else {
      res = res.concat(item);
    }
  });

  return res;
}
```

## 获取类型

- 手写一个 getType 函数,传入任意变量,可准确获取类型
- 如 number string boolean 等值类型
- 还有 object array map regexp 等引用类型

```ts
// 枚举
// 缺陷: 可能会忽略某些类型
// 增加了新类型,需要修改代码
function getType(x: any): string {
  // 通过typeof 判断值类型和function

  // 其余的'object'通过instanceof 枚举
  if (typeof x === 'object') {
    if (x instanceof Array) return 'array';
    if (x instanceof Map) return 'map';
    // .....
  }
}
```

```ts
// Object.prototype.toString.call()
function getType(x: any): string {
  const originType = Object.prototype.toString.call(x);
  const spaceIndex = originType.indexOf(' ');
  const type = originType.slice(spaceIndex + 1, -1);
  return type.toLowerCase();
}
```

## 手写 LazyMan

- 支持 sleep 和 eat 两个方法
- 支持链式调用
  示例

```js
const me = new LazyMan('nexus');
me.eat('苹果').eat('香蕉').sleep(5).eat('葡萄');
// 'nexus eat 苹果'
// 'nexus eat 香蕉'
// （等待5s）
// 'nexus eat 葡萄'
```

代码设计

- 由于有 sleep 功能,函数不能直接在调用时触发
- 初始化一个列表,把函数注册进去(**任务队列**)
- 由每个 item 触发 next 执行(遇到 sleep 则异步触发)

```ts
class LazyMan {
  private name: string;
  private tasks: Function[] = []; // 任务列表

  constructor(name: string) {
    this.name = name;
    setTimeout(() => {
      this.next();
    });
  }

  private next() {
    const task = this.tasks.shift(); // 取出当前tasks的第一个任务
    if (task) task();
  }

  eat(food: string) {
    const task = () => {
      console.info(`${this.name} eat ${food}`);
      // 执行下一个
      this.next(); // 立即执行下一个任务
    };
    this.tasks.push(task);
    return this; // 链式调用
  }

  sleep(second: number) {
    const task = () => {
      setTimeout(() => {
        console.info(`等待${second}s,执行下一个任务`);
        this.next();
      }, second * 1000);
    };
    this.tasks.push(task);
    return this;
  }
}
```

## 手写一个 curry 函数

- curry 返回的是一个函数
- 执行 fn,中间状态返回函数,如 add(1)或者 add(1)(2)
- 最后返回执行结果,如 add(1)(2)(3)

```ts
function curry(fn: Function) {
  const fnArgsLength = fn.length; // 传入函数的参数长度
  let args: any[] = [];
  // ts中,独立的函数,this需要声明类型,（不是参数）
  function calc(this: any, ...newArgs: any[]) {
    // 积累参数
    args = [...args, ...newArgs];
    if (args.length < fnArgsLength) {
      // 参数不够,返回函数
      return calc;
    } else {
      // 返回执行结果,slice截取参数,如果参数过多无效
      return fn.apply(this, args.slice(0, fnArgsLength));
    }
  }
  return calc;
}

// function add(a: number, b: number, c: number):number{
//   return a+b+c
// }
// add(10,20,30) //60
// const curryAdd = curry(add)
// curryAdd(10)(20)(30) // 60
```
