## `Object.create`

实现思路: 将传入的对象作为原型对象

```js
function create(obj) {
  function fn() {}
  fn.prototype = obj;
  return new fn();
}
```

## `instanceof`

实现思路:

- 获取右侧对象的原型对象
- 循环遍历左侧对象的原型与右侧相对比

```js
function myInstanceof(left, right) {
  left = Object.getPrototypeOf(left);
  right = right.prototype;
  while (true) {
    if (!left) return false;
    if (left === right) return true;
    left = Object.getPrototypeOf(left);
  }
}
```

## `new`模拟实现

实现思路:

- 新建一个对象
- 利用`Object.create`创建原型链关系
- 利用`.call`方法执行构造函数,`this`是这个新建的对象
- 判断返回值类型,如果是值类型,返回这个对象,如果是引用类型,返回这个引用类型

```js
function myNew(fn, ...args) {
  let newObj = Object.create(fn.prototype);
  let res = fn.call(newObj, ...args);
  return res && (typeof res === 'function' || typeof res === 'object')
    ? res
    : neObj;
}
```

## 数组拍平

- 写一个 js 函数,实现数组扁平化,只减少一级嵌套
- 输入`[1,[2,[3]],4]`,输出`[1,2,[3],4]`

```ts
// push
function flatten1(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      item.forEach((n) => res.push(n));
    } else {
      res.push(item);
    }
  });

  return res;
}
```

```ts
// concat
function flatten2(arr: any[]): any[] {
  let res: any[] = [];

  arr.forEach((item) => {
    res = res.concat(item);
  });
  return res;
}
```

## 深度拍平

```ts
function flattenDeep(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep(item);
      flatItem.forEach((n) => res.push(n));
    } else {
      res.push(item);
    }
  });

  return res;
}
```

```ts
function flattenDeep(arr: any[]): any[] {
  const res: any[] = [];
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      const flatItem = flattenDeep(item);
      res = res.concat(flatItem);
    } else {
      res = res.concat(item);
    }
  });

  return res;
}
```

## 获取类型

- 手写一个 getType 函数,传入任意变量,可准确获取类型
- 如 number string boolean 等值类型
- 还有 object array map regexp 等引用类型

```ts
// 枚举
// 缺陷: 可能会忽略某些类型
// 增加了新类型,需要修改代码
function getType(x: any): string {
  // 通过typeof 判断值类型和function

  // 其余的'object'通过instanceof 枚举
  if (typeof x === 'object') {
    if (x instanceof Array) return 'array';
    if (x instanceof Map) return 'map';
    // .....
  }
}
```

```ts
// Object.prototype.toString.call()
function getType(x: any): string {
  const originType = Object.prototype.toString.call(x);
  const spaceIndex = originType.indexOf(' ');
  const type = originType.slice(spaceIndex + 1, -1);
  return type.toLowerCase();
}
```
