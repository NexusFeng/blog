## `Object.create`
实现思路: 将传入的对象作为原型对象
```js
function create(obj) {
  function fn() {}
  fn.prototype = obj
  return new fn()
}
```
## `instanceof`
实现思路:  
- 获取右侧对象的原型对象  
- 循环遍历左侧对象的原型与右侧相对比
```js
function myInstanceof(left, right) {
  left = Object.getPrototypeOf(left)
  right = right.prototype
  while(true) {
    if (!left) return false
    if (left === right) return true
    left = Object.getPrototypeOf(left)
  }
}
```
## `new`模拟实现
实现思路: 
- 新建一个对象
- 利用`Object.create`创建原型链关系
- 利用`.call`方法执行构造函数,`this`是这个新建的对象
- 判断返回值类型,如果是值类型,返回这个对象,如果是引用类型,返回这个引用类型
```js
function myNew(fn, ...args){
  let newObj = Object.create(fn.prototype)
  let res = fn.call(newObj, ...args)
  return res && (typeof res === 'function' || typeof res === 'object')? res : neObj
}
```
## 手写`promise`
```js
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function myPromise(fn) {
  // 保存初始化状态
  var self = this
  // 初始化状态
  this.state = PENDING
  // 用于保存resolve或者rejected传入的值
  this.value = null
  // 用于保存resolve的回调函数
  this.resolvedCallbacks = []
  // 用于保存reject的回调函数
  this.rejectedCallbacks = []
  // 状态变为resolved方法
  function resolved(value) {
    // 判断传入元素是否为Promise值,如果是,则状态改变必须等于前一个状态改变后再进行改变
  }
}
```