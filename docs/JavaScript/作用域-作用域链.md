作用域: 作用域就是变量与函数的可见范围,即作用域控制着变量与函数的可见性和生命周期。js中,变量的作用域有全局作用域和函数作用域、块级作用域(ES6)
作用域链: 

- JavaScript引擎并非一行一行的分析和执行程序,而是一段一段的分析执行函数,在执行一段代码的时候会进行准备工作(执行上下文【execution context】,js引擎创建执行上下文栈【Exexution context stack,ECS】来管理执行上下文)
- js的可执行代码: 全局代码、函数代码、eval代码

函数上下文：  
在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。
活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。  
活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。  

变量对象的创建：
1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值

AO/VO关系:  
未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。  
它们其实都是同一个对象，只是处于执行上下文的不同生命周期；  

执行上下文(EC)  
每个执行上下文都有三个属性:变量对象(vo),作用域链,this  
一个执行上下文的生命周期包括两个阶段：  
- 1.创建阶段  
  在这个阶段,执行上下文分别创建变量对象,建立作用域链,以及确定this指向
- 2.代码执行阶段
  完成变量赋值,函数引用,以及执行其他代码  

作用域和执行上下文最大的区别: 执行上下文在运行时确定,随时可能改变;作用域在定义时就确定,并且不会改变

思考:
```js
function foo() {
  console.log(a)
  a = 1
}
foo() // Uncaught ReferenceError: a is not defined
// 函数中的a并没有通过var关键字声明,所以不会存放在AO中
// 执行console时,AO值为:
AO = {
  arguments: {
    length: 0
  }
}

function foo () {
  a = 1
  console.log(a)
}
foo() // 1
// 全局对象已经被赋予了a属性,打印1

var a = 1
function a() {

}
console.log(a)// 1

console.log(a)//打印函数
var a = 1
function a() {

}
// 在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 
```