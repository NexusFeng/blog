## 原型链继承(将父类的实例作为子类的原型)
```js
function Parent() {
  this.name = 'keke'
}
Parent.prototype.getName = function() {
  console.log(this.name)
}
function Child() {

}
Child.prototype = new Parent()
let child1 = new Child()
console.log(child1.getName()) // keke
```
缺点:  
- 引用类型的属性被所有实例共享
- 无法实现多继承,应为原型一次只能被一个实例更改
- 创建子类实例时,无法向父构造器传参
```js
function Parent () {
  this.name = ['keke', 'kexin']
}
function Child() {

}
Child.prototype = new Parent()
let child1 = new Child()
child1.name.push('hehe')
console.log(child1.name) // ['keke', 'kexin', 'hehe']
let child2 = new Child()
console.log(child2.name) // ['keke', 'kexin', 'hehe']
```
- 在创建Child实例时,不能向Parent传参

## 借用构造函数(经典继承)
```js
function Parent() {
  this.name = ['keke', 'kexin']
}
function Child() {
  Parent.call(this)
}
let child1 = new Child()
child1.name.push('hehe')
console.log(child1.name) // ['keke', 'kexin', 'hehe']
let child2 = new Child()
console.log(child2.name) // ['keke', 'kexin']
```
优点:  
- 避免了引用类型的属性被所有实例共享
- 可以在Child中向Parent传参
```js
function Parent(name) {
  this.name = name
}

function Child(name) {
  Parent.call(this, name)
}

let child1 = new Child('keke')
console.log(child1.name) // keke
let child2 = new Child('kexin')
console.log(child2.name) // kexin
```
缺点:  
方法都在构造函数中定义,每次创建实例都会创建一遍方法

## 组合继承
原型链和经典继承的合体
```js
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}
Parent.prototype.getName = function() {
  console.log(this.name)
}
function Child(name, age){
  Parent.call(this, name)
  this.age = age
}
Child.prototype = new Parent()

let child1 = new Child('keke', '18')

child1.colors.push('black')

console.log(child1.name)//keke
console.log(child1.age) // 18
console.log(child1.colors)// ['red', 'blue', 'green', 'black']

let child2 = new Child('kexin', '20')
console.log(child1.name)//kexin
console.log(child2.age)//20
console.log(child1.colors)// ['red', 'blue', 'green']
```
优点: 融合原型链继承和构造函数的优点,最常用的继承模式  
缺点: 调用两次父构造函数
```js
// 设置子类实例的原型时
Child.prototype = new Parent()
// 创建子类实例的时候
var child1 = new Child('keke', '18')
```

## 原型式继承
```js
function createObj(o) {
  function F(){}
  F.prototype = o
  return new F()
}
```
就是ES5中`Object.create`的模拟实现,将传入的对象作为创建的对象的原型   
缺点:  
包含引用类型的属性值始终都会共享相应的值,这点和原型链继承一样
```js
var person = {
  name: 'keke',
  friends: ['kexin', 'hehe']
}
var person1 = createObj(person)
var person2 = createObj(person)

person1.name = 'person1'
console.log(perosn2.name) //keke

person1.friends.push('dada')
console.log(perosn2.friends) //['kexin','hehe','dada']
```
注意:  
修改person1.name的值,person2.name的值并未改变,并不是因为person1和person2有独立的name值,而是因为person.name = 'person',给person1添加了name值,并非修改了原型上的name值

## 寄生式继承
创建一个仅用于封装继承过程的函数,该函数在内部以某种形式来做增强对象,最后返回对象
```js
function createObj(o) {
  var clone = object.create(o)
  clone.sayName = function() {
    console.log('hi')
  }
  return clone
}
```
缺点: 跟借用构造函数模式一样,每次创建对象都会创建一遍方法

## 寄生组合式继承
```js
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}
Parent.prototype.getItem = function () {
  console.log(this.name)
}
function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
function object(o) {
  function F(){}
  F.prototype = o
  return new F()
}
function prototype(child, parent) {
  var prototype = object(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

// 使用
prototype(Child, Parent)
```
优点: 只调用了一次父构造函数,并且避免了再Parent.prototype上面创建不必要的、多余的属性。与此同时,原型链还能保持不变。普遍认为,寄生组合式继承是引用类型最理想的继承范式