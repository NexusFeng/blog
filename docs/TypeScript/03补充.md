---
title: 3.补充
---
## 接口的继承
```ts
interface UserItem {
  name: string,
  age: number,
  enjoyFood: string[]
}

interface Admin extends UserItem {
  permission: number
}
```
**通过`Omit`舍弃某些属性`type Omit<T, K extends string | number | symbol>`T代表已有的一个对象类型,K代表要删除的属性名**
```ts
interface Admin extends Omit<UserItem, 'name' | 'age'> {
  permission: number
}
```

## 函数重载
```ts
function greet(name: string | string[]): string | string[]{
  ....
}
```
重载改写
```ts
function greet(name: string):string
function greet(name: string[]): string[]
function greet(name: string | string[]) {
  ....
}
```
## 断言
```ts
function greet(name: string | string[]): string | string[] {
  ....
}

const greetings = greet(['tom', 'ptt'])

console.log(greetings.join(' '))// 报错,虽然这里是string[],但是ts会认为这是string | string[]

const greetings = greet(['tom', 'ptt']) as string[]
console.log(greetings.join(' '))// 可以正常使用join方法
```
## 编译
利用`ts-node`将ts编译成为js,通常还需要配置一个`--module`选项,用于决定编译后是CJS规范还是ESM规范,但是如果缺省,会根据`--target`来决定
## any和unknown的区别
unknown类型会更加严格,在对unknown类型的值执行大多数操作之前必须进行某种形式的检查(也不能将值赋给any和unknown之外的变量类型)，而any不用  
可以使用类型断言将unknown类型指定为一个更具体的类型  
```ts
const val:unknown = 'hello'
const bar:string = val as string
```
## Declare
js库或着框架没有ts声明文件,但是,如果要在ts文件中使用他们而没有任何编译错误,则需要使用declare关键字。declare关键字用于环境声明和要定义可能其他位置存在的变量的方法
## 访问修饰符
- public 类的所有成员，子类以及该类的实例都可以访问
- projected 该类及其子类的所有成员都可以访问他们,但是子类的实例无法访问
- private 只有类放入成员可以访问他们
## interface和type的区别
相同点
- 都可以描述一个对象或者函数
- 都允许扩展(extends)
不同点
- type可以声明基本类型别名,联合类型，元组等类型
- interface能够声明合并

------

## readonly 对于数组与元组和对象类型的不同之处
- 你只能将整个数组/元组标记为只读，而不能像对象那样标记某个属性为只读。
- 一旦被标记为只读，那这个只读数组/元组的类型上，将不再具有 push、pop 等方法（即会修改原数组的方法），因此报错信息也将是类型 xxx 上不存在属性“push”这种。这一实现的本质是只读数组与只读元组的类型实际上变成了 ReadonlyArray，而不再是 Array。

## 字面量类型
- 字符串字面量类型
- 数字字面量类型
- 布尔字面量类型
- 对象字面量类型
```ts
const str: "lal" = "lal";
const num: 599 = 599;
const bo ol: true = true;
```
## 联合类型
- 对于联合类型中的函数类型,需要用括号包裹起来
- 你可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中

**常用的使用场景**
user 属性会满足普通用户与 VIP 用户两种类型，这里 vip 属性的类型基于布尔字面量类型声明。我们在实际使用时可以通过判断此属性为 true ，确保接下来的类型推导都会将其类型收窄到 VIP 用户的类型（即联合类型的第一个分支）
```ts
interface Tmp {
  user: | {
    vip: true,
    expires: string
  } 
  | {
    vip: false,
    promotion; string
  }
}

declare var tmp: Tmp
```

## 枚举和对象的区别
- 对象是单向映射,只能是从键映射到值
- 枚举是双向映射,可以从键映射到值,也可一从值映射到键(**仅有值为数字的枚举成员才能进行双向枚举,字符串成员仍然只能进行单次映射**)
```ts
enum Items {
  Foo,
  Bar,
  Baz
}

const fooValue = Items.Foo; // 0
const fooKey = Items[0]; // "Foo"
```