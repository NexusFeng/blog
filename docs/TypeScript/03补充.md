---
title: 3.补充
---
## 接口的继承
```ts
interface UserItem {
  name: string,
  age: number,
  enjoyFood: string[]
}

interface Admin extends UserItem {
  permission: number
}
```
**通过`Omit`舍弃某些属性`type Omit<T, K extends string | number | symbol>`T代表已有的一个对象类型,K代表要删除的属性名**
```ts
interface Admin extends Omit<UserItem, 'name' | 'age'> {
  permission: number
}
```

## 函数重载
```ts
function greet(name: string | string[]): string | string[]{
  ....
}
```
重载改写
```ts
function greet(name: string):string
function greet(name: string[]): string[]
function greet(name: string | string[]) {
  ....
}
```
## 断言
```ts
function greet(name: string | string[]): string | string[] {
  ....
}

const greetings = greet(['tom', 'ptt'])

console.log(greetings.join(' '))// 报错,虽然这里是string[],但是ts会认为这是string | string[]

const greetings = greet(['tom', 'ptt']) as string[]
console.log(greetings.join(' '))// 可以正常使用join方法
```
## 编译
利用`ts-node`将ts编译成为js,通常还需要配置一个`--module`选项,用于决定编译后是CJS规范还是ESM规范,但是如果缺省,会根据`--target`来决定
## any和unknown的区别
unknown类型会更加严格,在对unknown类型的值执行大多数操作之前必须进行某种形式的检查(也不能将值赋给any和unknown之外的变量类型)，而any不用  
可以使用类型断言将unknown类型指定为一个更具体的类型  
```ts
const val:unknown = 'hello'
const bar:string = val as string
```
## Declare
js库或着框架没有ts声明文件,但是,如果要在ts文件中使用他们而没有任何编译错误,则需要使用declare关键字。declare关键字用于环境声明和要定义可能其他位置存在的变量的方法
## 访问修饰符
- public 类的所有成员，子类以及该类的实例都可以访问
- projected 该类及其子类的所有成员都可以访问他们,但是子类的实例无法访问
- private 只有类放入成员可以访问他们
## interface和type的区别
相同点
- 都可以描述一个对象或者函数
- 都允许扩展(extends)
不同点
- type可以声明基本类型别名,联合类型，元组等类型
- interface能够声明合并