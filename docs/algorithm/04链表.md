# 链表
- 多个元素组成的链表
- 元素储存不连续,用next指针连在一起
- 物理结构
- **Map**、数组和链表都是有序结构(**Set**、对象是一个无序结构)
```js
// 数组有序
let arr = []
arr.push(1)
arr.push(2)
arr.push(3)
arr.push('a')
console.log(arr) // 1,2,3,a
// 对象无序
let obj = {}
obj['a'] = 'aaa'
obj[1] = 1
obj[2] = 2
obj[3] = 3
console.log(Object.keys(obj))// '1','2','3','a'

```

![链表](/docs/images/algorithm/链表.PNG)

## 和数组的区别
- 数组: 增删非首尾元素时往往需要移动元素
- 链表: 增删非首尾元素时往往不需要移动元素,只需要更改next的指向即可
- 链表: 查询慢O(n), 新增和删除快O(1)
- 数组: 查询快O(1), 新增和删除慢O(n)

## js中
js中没有链表,可以用Object模拟
```js
const a = { val: 'a'}
const b = { val: 'b'}
const c = { val: 'c'}
const d = { val: 'd'}
a.next = b
b.next = c
c.next = d

// 遍历链表
let p = a
while(p) {
    consple.log(p.val)
    p = p.next
}

// 插入
const e = {val: 'e'}
c.next = e
e.next = d

// 删除
c.next = d
```

## leetCode 237 删除链表中的节点
请编写一个函数,使其可以删除某个链表中给定的(非末尾)节点,你将只被给定要求被删除的节点\
解题思路:
- 无法直接获取被删除节点的上个节点
- 将被删除节点转移到下个节点
步骤:
- 将被删除节点的值改为下个节点的值
- 删除下个节点
```js
var deleteNode = function(node) {
  node.val = node.next.val
  node.next = node.next.next
}

// 时间复杂度O(1),空间复杂度O(1)
```

## leetCode 206 反转链表
反转一个单链表，输入1->2->3->4->5->null,输出5->4->3->2->1->null\
解题思路:
- 反转两个节点: 将n+1的next指向n
- 反转多个节点: 双指针遍历链表，重复上边操作
解题步骤:
- 新建两个指针,双指针一前一后遍历链表
- 反转双指针
```js
//迭代版
var reverseList = function(head) {
  let p1 = head
  let p2 = null
  while(p1) {
    const tmp = p1.next
    p1.next = p2
    p2 = p1
    p1 = tmp
  }
  return p2
}
// 时间复杂度O(n),空间复杂度O(1)
//递归版
var reverseList = function(head) {
  const reverse = (pre, head) => {
    if(!head) return pre
    const temp = head.next
    head.next = pre
    pre = head
    return reverse(pre, temp)
  }
  return reverse(null, head)
}
```
p1 1 2 3 4 5
p2 0 1 2 3 4

tmp = 2, p2 = 1, p1 = 2, p1.next = null
tmp = 3, p2 = 2, p1 = 3, p1.next = 4

## leetCode 2 两数相加
解题思路:
- 模拟相加操作
- 需要遍历链表
解题步骤:
- 新建一个空链表
- 遍历被相加的两个链表,模拟相加操作，将个位数追加到新链表上,将十位数留到下一位去相加
```js
var addTwoNumbers = function(l1, l2) {
  const l3 = new ListNode(0)
  let p1 = l1
  let p2 = l2
  let p3 = l3
  let carry = 0
  while(p1 || p2) {
    const v1 = p1 ? p1.val : 0
    const v2 = p2 ? p2.val : 0
    const val = v1 + v2 + carry
    carry = Math.floor(val/10)
    p3.next = new ListNode(val % 10)
    if (p1) p1 = p1.next
    if (p2) p2 = p2.next
    p3 = p3.next
  }
  if(carry){
    p3.next = new ListNode(carry)
  }
  return l3.next
}
// 时间复杂度O(n),空间复杂度O(n)
```

## leetCode 83 删除排序链表中的重复元素
解题思路；
- 因为链表是有序的,所以重复元素一定相邻
- 遍历链表,如果发现当前元素和下个元素值相同,就删除下个元素值

解题步骤:
- 遍历链表,如果发现当前元素和下个元素值相同,就删除下个元素值
- 遍历结束后,返回原链表的头部
```js
var deleteDuplicates = function(head) {
  let p = head
  while(p && p.next) {
    if(p.val === p.next.val) {
      p.next = p.next.next
    } else {
      p = p.next
    }
  }
  return head
}
// 时间复杂度O(n),空间复杂度O(1)
```

## leetCode 141 环形链表
解题思路；
- 两个人圆形操场同时跑,速度快的一定会超过速度慢的一圈
- 用一快一慢两个指针遍历链表,如果指针能够相逢,那么链表就有圈
解题步骤:
- 用一快一慢两个指针遍历链表,如果指针能够相逢,就返回true
- 遍历结束后,还没相逢就返回false
```js
var hasCycle = function(head) {
  let p1 = head
  let p2 = head
  while(p1 && p2 && p2.next){
    p1 = p1.next
    p2 = p2.next.next
    if (p1 === p2) {
      return true
    }
  }
  return false
}
// 时间复杂度O(n),空间复杂度O(1)
```

**原型链的本质是链表**