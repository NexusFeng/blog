# 树
- 一种**分层**数据的抽象模型
- 前端常见的树: DOM树、级联选择、树形控件....
- js中没有树,但是可以用Object和Array构建树
- 树的常用操作: 深度/广度优先遍历、先中后序遍历

## 树的深度与广度优先遍历
深度优先遍历(dfs): 尽可能深的搜索树的分支
- 访问根节点
- 对根节点的children挨个进行深度优先遍历
```js
const tree = {
  val: 'a',
  children: [
    {
      val: 'a',
      children: [
        {
          {
            val: 'd',
            children: []
          },
          {
            val: 'e',
            children: []
          }
        }
      ]
    },
    {
      val: 'c',
      children: [
        {
          {
            val: 'f',
            children: []
          },
          {
            val: 'g',
            children: []
          }
        }
      ]
    }
  ]
}

const dfs = (root) => {
  console.log(root)
  root.children.forEach(dfs)
}
dfs(tree)// a b d e c f g
```
广度优先遍历(bfs): 先访问离根节点最近的节点
- 新建一个队列,把根节点入队
- 把队头出队并访问
- 把队头的children挨个入队
- 重复第二、三步,直到队列为空
```js
const tree = {
  val: 'a',
  children: [
    {
      val: 'a',
      children: [
        {
          {
            val: 'd',
            children: []
          },
          {
            val: 'e',
            children: []
          }
        }
      ]
    },
    {
      val: 'c',
      children: [
        {
          {
            val: 'f',
            children: []
          },
          {
            val: 'g',
            children: []
          }
        }
      ]
    }
  ]
}

const bfs = (root) => {
  const q = [root]
  while(q.length > 0) {
    const n = q.shift()
    console.log(n.val)
    n.children.forEach(child => {
      q.push(child)
    })
  }
}

bfs(tree) // a b c d e f g
```

## 二叉树的先、中、后序遍历
### 二叉树
- 树中每个节点最多只能有两个子节点
- 在js中通常用Object来模拟二叉树

### 先序遍历
- 访问**根**节点
- 对根节点的**左**子树进行先序遍历
- 对根节点的**右**子树进行先序遍历
```js
const bt = {
  val: 1,
  left: {
    val: 2,
    left: {
      val: 4,
      left: null,
      right: null
    },
    right: {
      val: 5,
      left: null,
      right: null
    },
  },
  right: {
    val: 3,
    left: {
      val: 6,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    },
  }
}

const preOrder = (root) => {
  if(!root) return
  console.log(root.val)
  preOrder(root.left)
  preOrder(root.right)
}
preOrder(bt)
```

## 中序遍历
- 对根节点的**左**子树进行中序遍历
- 访问**根**节点
- 对根节点的**右**子树进行中序遍历
```js
const bt = {
  val: 1,
  left: {
    val: 2,
    left: {
      val: 4,
      left: null,
      right: null
    },
    right: {
      val: 5,
      left: null,
      right: null
    },
  },
  right: {
    val: 3,
    left: {
      val: 6,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    },
  }
}

const inOrder = (root) => {
  if(!root) return
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
}
inOrder(bt)
```

## 后序遍历
- 对根节点的**左**子树进行后序遍历
- 对根节点的**右**子树进行后序遍历
- 访问**根**节点
```js
const bt = {
  val: 1,
  left: {
    val: 2,
    left: {
      val: 4,
      left: null,
      right: null
    },
    right: {
      val: 5,
      left: null,
      right: null
    },
  },
  right: {
    val: 3,
    left: {
      val: 6,
      left: null,
      right: null
    },
    right: {
      val: 7,
      left: null,
      right: null
    },
  }
}

const postOrder = (root) => {
  if(!root) return
  postOrder(root.left)
  postOrder(root.right)
  console.log(root.val)
}
postOrder(bt) // 4 5 2 6 7 3 1
```


