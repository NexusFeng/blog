# 排序和搜索
排序: 把某个乱序的数组变成升序或者降序的数组\
搜索: 找出数组中某个元素的下标
js中的排序: 数组的sort方法\
js中的搜索: 数组的indexOf方法
## 排序算法
冒泡排序、选择排序、插入排序、归并排序、快速排序.....
### 冒泡排序
思路:
- 比较所有相邻元素,如果第一个比第二个大,则交换他们
- 一轮下来,可以保证最后一个数是最大的
- 执行n-1轮,就可以完成排序
```js
Array.prototype.bubbleSort = function() {
  for(let i = 0; i < this.length - 1; i++) {
    for(let j = 0; j < this.length - i - 1; j++) {
      if(this[j] > this[j + 1]) {
        const temp = this[j]
        this[j] = this[j + 1]
        this[j + 1] = temp
      }
		}
  }
}

const arr = [5, 4, 3, 2, 1]
arr.bubbleSort()
// 时间复杂度O(n^2)
```

### 选择排序
思路:
- 找到数组中的最小值,选中它并将其放置在第一位
- 接着找到第二小的值,选中它并将其放置在第二位
- 依次类推,执行n-1轮
```js
Array.prototype.selectionSort = function() {
	for(let i = 0; i < this.length - 1; i++) {
		let indexMin = i
		for(let j = i; j < this.length; j++) {
			if(this[j] < this[indexMin]) {
				indexMin = j
			}
		}
		if(indexMin !== i) {
			const temp = this[i]
			this[i] = this[indexMin]
			this[indexMin] = temp
		}
	}
}

const arr = [5, 4, 3, 2, 1]
arr.selectionSort()
// 时间复杂度O(n^2)
```

### 插入排序
思路:
- 从第二个数开始**往前比**
- 比它大就**往后排**
- 以此类推进行到最后一个数
```js
Array.prototype.insertionSort = function() {
	for(let i = 1; i < this.length; i++) {
		const temp = this[i]
		let j = i
		while(j > 0) {
			if(this[j - 1] > temp) {
				this[j] = this[j - 1]
			} else {
				break
			}
			j -=1
		}
		this[j] = temp
	}
}

const arr = [2, 4, 3, 5, 1]
arr.insertionSort()
// 时间复杂度O(n^2)
```

### 归并排序(火狐浏览器sort实现方式)
思路:
- 分: 把数组劈成两半,再递归的对子数组进行'分'操作,直到分成一个个单独的数
- 合: 把两个数合并为有序数组,再对有序数组进行合并,直到全部子数组合并为一个完整数组
合并两个有序数组:
- 新建一个空数组res,用于存放最终排序后的数组
- 比较两个有序数组的头部,较小者出队并推入res中
- 如果两个数组还有值,就重复第二步
```js
Array.prototype.mergeSort = function() {
	const rec = () => {
		if(arr.length === 1) return arr
		const mid = Math.floor(arr.length / 2)
		const left = arr.slice(0, mid)
		const right = arr.slice(mid, arr.length)
		const orderLeft = rec(left)
		const orderRight = rec(right)
		const res = []
		while(orderLeft.length || orderRight.length) {
			if(orderLeft.length && orderRight.length) {
				res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())
			} else if(orderLeft.length) {
				res.push(orderLeft.shift())
			} else if(orderRight.length) {
				res.push(orderRight.shift())
			}
		}
		return res
	}
	const res = rec(this)
	res.forEach((n, i) => {this[i] = n})
}

const arr = [2, 4, 3, 5, 1]
arr.mergeSort()
// 分:时间复杂度O(logN) 合: 时间复杂度O(n) 
// 时间复杂度O(n*logN)
```

## 搜索算法
顺序搜索、二分搜索......

