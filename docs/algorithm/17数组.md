## leetCode 56 合并区间

- 开始遍历,尝试合并 prev 和 cur,合并后更新到 prev
- 合并后的新区间还可能和后面的区间重合,继续尝试合并新的 cur,更新给 prev
- 知道不能合并——`prev[1]<cur[0]`,此时将 prev 区间推入 res 数组

```js
var merge = function (intervals) {
  if (intervals.length === 0) return [];
  intervals.sort((a, b) => {
    return a[0] - b[0];
  });
  let res = [];
  let prev = intervals[0];
  for (let i = 1; i < intervals.length; i++) {
    let cur = intervals[i];
    if (prev[1] >= cur[0]) {
      prev[1] = Math.max(cur[1], prev[1]);
    } else {
      res.push(prev);
      prev = cur;
    }
  }
  res.push(prev);
  return res;
};
```

## leetCode 48 旋转图像

- 规定在原矩阵改,可以新建一个旋转后的矩阵，然后覆盖原矩阵
```js
var rotate = function(matrix) {
  const n = matrix.length
  const matrix_new = new Array(n).fill(0).map(() => new Array(n).fill(0))
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      matrix_new[j][n-i-1] = matrix[i][j]
    }
  }
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      matrix[i][j] = matrix_new[i][j]
    }
  }
};
```

## leetCode 1886 判断矩阵经轮转后是否一致

- 矩阵旋转4次就会回到原位
- 对比每一次的旋转结果是否相等,如果四次都不相等,就不一致
```js
var findRotation = function(mat, target) {
 let n = mat.length
 const rotate = grid => {
  // 先对角翻转
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < i; j++) {
       [grid[i][j], grid[j][i]] = [grid[j][i], grid[i][j]]
     }
   }
  // 再左右翻转
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n/2; j++) {
       [grid[i][j], grid[i][n - j - 1]] = [grid[i][n - j - 1], grid[i][j]]
     }
   }
 }
 return [0,0,0,0].some(() => {
   rotate(mat)
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n; j++) {
       if(mat[i][j] !== target[i][j]) return false
     }
   }
   return true
 })
};
```

也可用上道题解法
```js
var findRotation = function(mat, target) {
 let n = mat.length
 const rotate = grid => {
  const grid_new = new Array(n).fill(0).map(() => new Array(n).fill(0))
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      grid_new[j][n-i-1] = grid[i][j]
    }
  }
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      grid[i][j] = grid_new[i][j]
    }
  }
 }
 return [0,0,0,0].some(() => {
   rotate(mat)
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n; j++) {
       if(mat[i][j] !== target[i][j]) return false
     }
   }
   return true
 })
};
```