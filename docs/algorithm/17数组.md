## leetCode 56 合并区间

- 开始遍历,尝试合并 prev 和 cur,合并后更新到 prev
- 合并后的新区间还可能和后面的区间重合,继续尝试合并新的 cur,更新给 prev
- 知道不能合并——`prev[1]<cur[0]`,此时将 prev 区间推入 res 数组

```js
var merge = function (intervals) {
  if (intervals.length === 0) return [];
  intervals.sort((a, b) => {
    return a[0] - b[0];
  });
  let res = [];
  let prev = intervals[0];
  for (let i = 1; i < intervals.length; i++) {
    let cur = intervals[i];
    if (prev[1] >= cur[0]) {
      prev[1] = Math.max(cur[1], prev[1]);
    } else {
      res.push(prev);
      prev = cur;
    }
  }
  res.push(prev);
  return res;
};
```

## leetCode 48 旋转图像

- 规定在原矩阵改,可以新建一个旋转后的矩阵，然后覆盖原矩阵
```js
var rotate = function(matrix) {
  const n = matrix.length
  const matrix_new = new Array(n).fill(0).map(() => new Array(n).fill(0))
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      matrix_new[j][n-i-1] = matrix[i][j]
    }
  }
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      matrix[i][j] = matrix_new[i][j]
    }
  }
};
```

## leetCode 1886 判断矩阵经轮转后是否一致

- 矩阵旋转4次就会回到原位
- 对比每一次的旋转结果是否相等,如果四次都不相等,就不一致
```js
var findRotation = function(mat, target) {
 let n = mat.length
 const rotate = grid => {
  // 先对角翻转
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < i; j++) {
       [grid[i][j], grid[j][i]] = [grid[j][i], grid[i][j]]
     }
   }
  // 再左右翻转
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n/2; j++) {
       [grid[i][j], grid[i][n - j - 1]] = [grid[i][n - j - 1], grid[i][j]]
     }
   }
 }
 return [0,0,0,0].some(() => {
   rotate(mat)
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n; j++) {
       if(mat[i][j] !== target[i][j]) return false
     }
   }
   return true
 })
};
```

也可用上道题解法
```js
var findRotation = function(mat, target) {
 let n = mat.length
 const rotate = grid => {
  const grid_new = new Array(n).fill(0).map(() => new Array(n).fill(0))
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      grid_new[j][n-i-1] = grid[i][j]
    }
  }
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      grid[i][j] = grid_new[i][j]
    }
  }
 }
 return [0,0,0,0].some(() => {
   rotate(mat)
   for(let i = 0; i < n; i++) {
     for(let j = 0; j < n; j++) {
       if(mat[i][j] !== target[i][j]) return false
     }
   }
   return true
 })
};
```

## leetCode 54 螺旋矩阵

```js
var spiralOrder = function(matrix) {
  if(!matrix.length || !matrix[0].length) {
    return []
  }
  const rows = matrix.length, columns = matrix[0].length
  const order = []

  let left = 0, right = columns - 1, top = 0, bottom = rows - 1
  while(left <= right && top <= bottom) {
    for(let column = left; column <= right; column++) {
      order.push(matrix[top][column])
    }
    for(let row = top + 1; row <= bottom; row++) {
      order.push(matrix[row][right])
    }
    if(left < right && top < bottom) {
      for(let column = right - 1; column > left; column--) {
        order.push(matrix[bottom][column])
      }
      for(let row = bottom; row > top; row--) {
        order.push(matrix[row][left])
      }
    }
    [left, right, top, bottom] = [left+1, right - 1, top + 1, bottom - 1]
  }
  return order
};
```

## leetCode 49 字母异位词分组
- 排序方式
```js
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let str of strs) {
    let array = Array.from(str)
    array.sort()
    let key  = array.toString()
    let list = map.get(key) ? map.get(key): new Array()
    list.push(str)
    map.set(key, list)
  }
  return Array.from(map.values())
}
```
- 计数方式
```js
var groupAnagrams = function(strs) {
  const map = new Object()
  for(let s of strs) {
    const count = new Array(26).fill(0)
    for(let c of s) {
      count[c.charCodeAt() - 'a'.charCodeAt()]++
    }
    map[count] ? map[count].push(s) : map[count] = [s]
  }
  return Object.values(map)
}
```