## 定义
保证一个类仅有一个实例,并提供一个访问它的全局访问点,也就是说,不管尝试去创建多少次,都只给返回第一次创建的那个唯一的实例
## ES6单例模式
```js
class SingleDog {
  constructor(name) {
    this.name = name
  }
  static getInstance(){
    if(!this.instance) {
      this.instance = new SingleDog()
    }
    return this.instance
  }
}
let w1 = SingleDog.getInstance()
let w2 = SingleDog.getInstance()
console.log(w1 === w1)// true
```
## ES5单例模式(闭包的方式)
```js
function SingleDog(name) {
  this.name = name
}
// 类上的方法,只可以通过类来访问,而不能通过实例访问
SingleDog.getInstance = function(function(){
  let instance
  return function(name) {
    if(!instance) {
      instance = new SingleDog(name)
    }
    return instance
  }
})()
let w1 = SingleDog.getInstance()
let w2 = SingleDog.getInstance()
console.log(w1 === w1)// true
```

## vuex中的单例模式
当调用Vue.use()方法时,就会安装vuex插件,也就是说每install一次，就会尝试给Vue实例注入一个Store
```js
// vuex install方法

let Vue
...

export function install(_Vue){
  // 判断传入的vue实例对象是否已经被install过(是否有唯一的state)
  if(Vue && _Vue === Vue) {
    if (process.env.NODE_ENV !== 'production') {
      console.error('.....')
    }
    return
  }
  // 若没有,则为这个Vue实例对象install一个唯一的vuex
  Vue = _Vue
  // 将vuex的初始化逻辑写进vue的钩子函数里
  applyMixin(Vue)
}
```