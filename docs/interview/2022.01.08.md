## 1.对于原型及原型链的理解
- 解释原型及原型链和原型链的尽头是null
- 说出隐式原型和显式原型
- 原型链的好处
  
在JS中使用构造函数来新建一个对象,这个对象的内部有一个隐式原型(`对象.__proto__`属性),这个隐式原型指向的是构造函数的显式原型对象(`构造函数.prototype`),如果这个对象是另一个构造函数的原型对象,这就形成了一种链式关系,也叫原型链,通过`__proto__`,一层一层往上寻找,在原型链的尽头是`Object.prototype.__proto__`,它指向的是`null`  

好处:如果一个属性或方法在该实例对象上没有找到的话,就会通过原型链去往上一层层去寻找,找到后就可以使用。可以做公共方法的封装,一般放在原型链上

## 2.js中有哪些继承方式,你觉得最好的继承方式是哪一种
继承方式:原型链继承、借用构造函数继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承、类继承(ES6)

最好的继承方式: 寄生组合式继承  

寄生组合继承的过程:   
主要是将寄生式继承和组合式继承组合的方式,在子类中利用`.call()`方法执行父类的方法,通过`Object.create()`方法去实现让子类的prototype等于父类prototype,同时,由于子类的原型对象发生了变化,所以,子类.prototype.constructor发生了变化,所以得再指向子类。简单来说,通过`call`方法实现父类方法和属性的继承,通过`Object.create()`实现父类原型对象的属性和方法的继承  

好处: 这样只调用了一次父构造函数,避免了子类实例和子类原型对象上生成重复的方法和属性
```js
function Parent(name) {
  this.name = name
  getItem: function() {

  }
}
Parent.prototype.getItem = function() {
  console.log(this.name)
}
function Child(name) {
  Parent.call(this,name)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```
## 3.js中改变this指向有哪些方法
bind、call、apply
### 4.这三者之间的区别
- bind、call和apply第一个参数都是要传入的`this`,当传入`null`或`undefined`时,`this`指向`window`。在参数传入的时候,bind、call传入的是多个参数,而apply传入的是数组或类数组对象
- bind返回的是一个函数并且不会被执行,而apply和call返回的是执行结果
- 当bind返回的函数作为构造函数的时候,bind时指定的`this`值会失效,但是参数依然生效,使用`new`的时候`this`指向构造出来的实例对象
- bind可以实现两次传参,调用函数的时候会把两次传参合并起来,类似于柯里化传参
利用这个特性,如果写的方法是一个通用方法,在bind时候可以把通用的一些参数传递进去,之后再别人调用这个方法的时候不用再把通用的参数传递一遍
**进大厂bind手写是关键**

## 5.js本身有哪些this指向
- **函数调用的时候**,`this`指向全局对象
- **对象的方法调用的时候**,`this`指向这个对象
- **构造器调用(new 调用)**,`this`指向新创建的实例对象
- **箭头函数**,`this`是自己作用域的上一层继承this

## 6.箭头函数和普通函数的区别
- 箭头函数写法比普通函数更加简洁
- **箭头函数没有自己的`this`,并且继承来的`this`不会改变**
- **箭头函数没有`prototype`(没有显示原型,但是有隐式原型__proto__)**
- 箭头函数不能用作`Generator`函数,不能使用`yield`关键字
- 箭头函数没有自己的`arguments`
- `band`、`call`、`apply`不能改变箭头函数`this`指向
### 7.箭头函数能调用band、call、apply改变this指向吗？为什么
**可以调用,但是没有效果**,原因在于,箭头函数也是函数,他的隐式原型__proto__是`Function.prototype`,在他上边会有band、call、apply方法供函数调用  
扩展:任何函数的_proto_都是Function.prototype,并且Function._proto_和Function.prototype是相等的,函数是个特殊情况,其他的不会出现自己的隐式原型和自己的显式原型一样的情况

## 8.连续调用bind的结果
多次bind输出的值是第一次bind的值  
**bind一旦this确定就不能修改**
```js
let a = 'a-window'
const o = {
  a: 'a-o'
}
const c = {
  a: 'a-c'
}
function test() {
  console.log(this.a)
}
test.bind(o).bind(c).bind(c)()//a-o
//this指向的是O,之后再多次调用bind是无效的
```
## 9.`instanceof`的实现原理
原理：如果是`a instanceof b`,会判断a的隐式原型(a.__prpto__)是否和b的显式原型(b.prototype)相等,如果不相等,会继续判断a的隐式原型的隐式原型(a.__proto__.__proto__),直到查找到a的原型链尽头,没找到则返回false
实现：利用`Object.getPrototypeOf`方法循环判断左侧实例的原型是否和右侧构造函数的prototype属性一致 
## 10.`new`关键字做了哪些事情,new的实现
- 第一步新创建一个对象
- 第二步通过使用`Object.create()`方法建立原型链继承,使新创建的对象的隐式原型(`__proto__`)指向构造函数的显式原型(`prototype`)
- 第三步通过使用`call`来执行构造函数,`this`指向这个新创建的对象,这样做可以得到构造函数内的属性和方法
- 第三步判断返回值,如果是`object`或者`function`时,返回自身的执行结果,如果不是,则返回新创建的对象
## 11.平时用到的es6相关的有哪些
模板字符串、解构、`Promise`、`let`、`const`、扩展运算符、Map和Set、类、数组`Array.form()`工厂函数、includes方法等
## 12.let、const和es5的var的区别
- `var`有变量提升,但是`const`和`let`没有
- `let`和`const`是块级作用域,var是全局作用域
- let和const有暂时性死区,未申明之前不可用,var没有
- 使用const必须赋初始值,let和var不用
### let用es5怎么实现
使用babel编译后,let是借助闭包或自执行函数来实现块级作用域的效果,在不同情况下let的编译结果不一样
#### 扩展: es5如何实现const
思路：利用`Object.defineProperty()`实现,由于es5环境没有block的概念,只能是挂载到某个对象下面,要么是全局window,要么是自定义一个object来当容器
```js
var _const = function _const(data, value) {
  window.data = value // 把要定义的data挂载到window下,并赋值value
  Object.defineProperty(window, data, {// 利用Object.defineProperty的能力劫持当前对象,并修改属性描述符
    enumerable: false,
    configurable: false,
    get: function () {
      return value
    }
    set: function(data) {
      if (data !== value) {//当要对当前进行赋值时,则抛出错误
        throw new TypeError('error')
      } else {
        return value
      }
    }
  })
}

_const('a',10)
console.log(a)
delete a
```
## 13.对闭包的理解
闭包其实就是一个内部函数引用了外部函数的变量,平常的做法是一个函数,在函数的内部返回一个匿名函数,这个匿名函数包含了这个函数的一些变量,这里的变量就会作为一个私有变量存储进来,之后这个函数调用结束的时候,这里的变量不会被垃圾回收机制回收,比如节流防抖。  
优点是可以定义函数私有变量,缺点是使用不当会造成内存泄漏
## 14.什么是js的垃圾回收机制？为什么闭包里的变量不会被垃圾回收机制回收？
说白了就是**定期**找出哪些不再使用的内存(变量),然后释放内存。常用的垃圾回收方式有标记清除和引用计数  
在函数执行结束后,函数外部的变量依然指向函数内部的局部变量,此时局部变量依然在被使用,所以不会回收
### 标记清除和引用计数,现代浏览器更倾向于哪一种呢
更倾向于标记清除。引用计数会引起**循环引用**问题  
一个函数内部一个对象a的一个属性引用另一个对象b,而另个一个对象b的属性引用这个对象a,在函数执行完后,a和b还将继续存在,他们的引用次数永远不会是0
```js
function fun() {
    let obj1 = {};
    let obj2 = {};
    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```
## 15.Promise的优点
平常通常用于请求的封装,解决了回调地狱的问题
`.then`具有值透传
## 16.Promise有哪些方法
- 实例方法：.then .catch .finally
- 静态方法：`Promise.all()`、`Promise.race()`、`Promise.any()`、`Promise.resolve()`、`Promise.reject()`
### Promise.all()和Promise.race()的区别
- `Promise.all()`传入的是一个`Promise`数组,如果数组里的所有状态变为成功,则返回他们的值组成的数据,如果有一个或多个是失败状态,则返回第一个失败的返回值  
- `Promise.race()`传入的也是一个数组,如果数组里有一个率先改变状态,则`Promise.race()`的状态也随之改变
#### 一个数组里想成功和失败的都返回,怎么做
使用`Promise.allSettled()`(ES2020)
## 17.Symbol
symbol表示独一无二的值,在实现apply、call用到  
**Symbol作为属性名,遍历对象的时候,不会出现在`for...in`、`for...of`循环中,也不会被`Object.keys()、Object.getOwnPropertyNames()`、`JSON.stringify()`返回**  
可以使用`Object.getOwnPropertySymbols()`方法
## 18.for...in和for...of区别
- for...of适用遍历数/数组对象/字符串/map/set等拥有迭代器(Iterator)对象的集合.但是不能遍历对象,因为没有迭代器对象.与forEach()不同的是,它可以正确响应break、continue和return语句
- for...of循环不支持普通对象,但如果你想迭代一个对象的属性,你可以用for...in循环或内建的Object.keys()方法
## 19.如果想判断一个数据类型到底是引用数据类型还是非引用数据类型代码怎么实现
```js
function isQuit(data) {
  if(typeof data === 'object' && data != null) {
    if(data instaceof Array) return 'array'
    if(data instaceof Object) return 'object'
  }
  return typeof data
}
```
## 20.js如何判断数组
- `Array.isArray`
- `Object.prototype.tostring.call()`
- `instanceof`
- 原型链`obj.__proto__ ==== Array.prototype`
## 21.splice和slice那个可以改变原数组
splice  
splice删除或新增元素,slice获取某个元素
### splice如何删除数组的最后一个元素
`数组.splice(数组.length-1, 1)`,splice第一个参数是起始位置,第二个参数是删除的个数,slice参数可选，起始位置和结束位置
## 22.0.1+0.2为什么不等于0.3
小数在转换二进制的时候,结果是无限循环的,计算机在存储的时候,存储位数是有限的,那麽就必须做一些近似值的取舍,这样就导致小数精度丢失了
### 0.2+0.2 == 0.4 
## 23.==和===区别 
==会发生类型转换,转换后相同时则为相同,===是不会发生类型转换,也会判断类型是否相同
## 24.RAF和RIC是什么
`requestAnimationFrame`: 告诉浏览器在下次重绘之前执行传入的回调函数(通常是操作dom,更新动画的函数);由于是每一帧执行一次,那执行的频率和浏览器刷新频率一致,一般每秒60次(浏览器每次必执行)  
`requestIdleCallback`: 会在浏览器空闲时间执行回调,也就是允许开发人员在主事件循环中执行低优先级任务,而不影响一些延迟关键事件.如果有多个回调,会按照先进先出原则执行,但是传入timeout,为了避免超时,有可能会打乱次序(浏览器不一定执行)
## 25.js事件循环
事件循环从宏任务队列开始,一开始宏任务队列中只有一个script(整体代码)任务,遇到任务源时,分发到相应的任务队列中.异步任务可分为task和micrtask两类(requestAnimationFrame既不属于macrotask,也不属于micrtask),不同的API注册的异步任务会依次进入自身对应的队列中,然后等待event loop 将他们依次压入执行栈中执行.执行栈执行完同步任务后,检查执行栈是否为空,如果为空,检查微任务队列是否为空,如果微任务队列不为空,则一次性执行完所有的微任务.如果微任务为空,则执行下一个宏任务。每次单个宏任务执行完之后,都会检查微任务队列是否为空,如果不为空,则会按照先进先出的方式执行完所有的微任务,然后执行下一个宏任务,以此循环。每次宏任务产生的微任务队列都是新创建的 宏任务队列只有一个.
## 26.输出
```js

```
## 27.js事件模型
相关链接：https://segmentfault.com/a/1190000006934031  
**事件：**事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。  
**事件流：**  
- 事件冒泡: 一种从下往上的传播方式.从子节点传播到最上层父节点
- 事件捕获：与事件冒泡相反  
  
**事件模型**  
- **DOM0 级事件模型:** 这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。
- **IE 事件模型:**在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。
- **DOM2 级事件模型:**在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行(默认是false冒泡)。
## 28.事件代理(事件委托)
事件在冒泡过程中会上传到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理(好处：减少了内存的消耗,节约了性能)
## 29.js如何异步加载脚本
defer(异步加载,等待dom节点渲染完成后执行,能保证脚本执行顺序)和async(异步加载,加载完后立即执行,不能保证脚本执行顺序)
## 30.什么是防抖和节流
防抖: 在一定时间内再次触发操作,上次触发的操作会被取消,重新计时(输入框Onchange事件实现远程实时查询,触发时取消上次的事件)
节流：在一定时间内再次触发时间,不予处理,直到执行完后再响应下次操作(解决一个需要频繁发生的事件,防止事件触发太多次,可使用在scroll函数的事件监听上,降低事件调用频率)
## 31.cookie、session、localStorage、sessionStorage区别
- **cookie：**其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
- **session：**不限制大小,服务端存储,与cookie值一致,一般储存用户的一些相关信息,我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
- **sessionStorage：**html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
- **localStorage：**html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。
## 32.浏览器内核是什么,包含哪些东西


## 33.cookie有哪些字段


## 34.cookie默认支持跨域吗,如何设置cookie跨域
不支持
- 在请求中设置`withCredentials`,设置为true
- Access-Control-Allow-Credentials 设置为 true
- Access-Control-Allow-Origin 设置为非*
## 35.什么是CORS
是一种跨域资源共享的方案
## 36.什么是OPTION预检请求,有什么作用

## 37.Content-Type有那些值可以配置
常用的有application/json、text/html、text/plain、application/x-www-form-urlencoded、multipart/form-data
## 38.知道的状态码有哪些

## 39.204是什么
应用场景：前端性能监控和错误上报
## 40.401和403区别

## 41.304代表命中了协商缓存,什么是强缓存和协商缓存

## 42.想要页面完全不缓存,该怎么设置

## 43.协商缓存什么情况下会被命中,强缓存什么情况下会不被命中

## 44.命中强缓存后的状态码是多少,从哪里读取缓存

## 45.get和post有什么区别

## 46.http2.0做了什么改动(4点),http3.0做了什么改动

## 47.什么是XSS和CSRF

## 48.flex布局有哪些属性

## 49.css怎么画一个朝右的三角形

## 50.单行文本溢出省略号怎么写

## 51.怎么在浏览器可视区域画一个最大的正方形

## 52.如果一个元素的padding设为百分比,那这个百分比基于什么设置的
基于当前元素宽度
## 53.浏览器盒子模型

## 54.css伪类和伪元素有什么区别
**一般结合例子说明**
## 55.css优先级如何计算

## 56.css重排和重绘

## 57.如何最大限度的减少浏览器回流和重绘
减少使用offset家族，clinet家族等？如果用,就用一个变量缓存
## 58.position有哪些属性值

## 59.flex:1由哪些属性组成

## 60.css如何画一个0.5px的线或者在浏览器设置5px的文本
css3缩放，移动端缩放
## 61.link和@import的区别

## 62.rem和em区别

## 63.git rebase 和 git merge 的区别