## 1.对于原型及原型链的理解
- 解释原型及原型链和原型链的尽头是null
- 说出隐式原型和显式原型
- 原型链的好处
  
在JS中使用构造函数来新建一个对象,这个对象的内部有一个隐式原型(`对象.__proto__`属性),这个隐式原型指向的是构造函数的显式原型对象(`构造函数.prototype`),如果这个对象是另一个构造函数的原型对象,这就形成了一种链式关系,也叫原型链,通过`__proto__`,一层一层往上寻找,在原型链的尽头是`Object.prototype.__proto__`,它指向的是`null`  

好处:如果一个属性或方法在该实例对象上没有找到的话,就会通过原型链去往上一层层去寻找,找到后就可以使用。可以做公共方法的封装,一般放在原型链上

## 2.js中有哪些继承方式,你觉得最好的继承方式是哪一种
继承方式:原型链继承、借用构造函数继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承、类继承(ES6)

最好的继承方式: 寄生组合式继承  

寄生组合继承的过程:   
主要是将寄生式继承和组合式继承组合的方式,在子类中利用`.call()`方法执行父类的方法,通过`Object.create()`方法去实现让子类的prototype等于父类prototype,同时,由于子类的原型对象发生了变化,所以,子类.prototype.constructor发生了变化,所以得再指向子类。简单来说,通过`call`方法实现父类方法和属性的继承,通过`Object.create()`实现父类原型对象的属性和方法的继承  

好处: 这样只调用了一次父构造函数,避免了子类实例和子类原型对象上生成重复的方法和属性
```js
function Parent(name) {
  this.name = name
  getItem: function() {

  }
}
Parent.prototype.getItem = function() {
  console.log(this.name)
}
function Child(name) {
  Parent.call(this,name)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```
## 3.js中改变this指向有哪些方法
bind、call、apply
### 4.这三者之间的区别
- bind、call和apply第一个参数都是要传入的`this`,当传入`null`或`undefined`时,`this`指向`window`。在参数传入的时候,bind、call传入的是多个参数,而apply传入的是数组或类数组对象
- bind返回的是一个函数并且不会被执行,而apply和call返回的是执行结果
- 当bind返回的函数作为构造函数的时候,bind时指定的`this`值会失效,但是参数依然生效,使用`new`的时候`this`指向构造出来的实例对象
- bind可以实现两次传参,调用函数的时候会把两次传参合并起来,类似于柯里化传参
利用这个特性,如果写的方法是一个通用方法,在bind时候可以把通用的一些参数传递进去,之后再别人调用这个方法的时候不用再把通用的参数传递一遍
**进大厂bind手写是关键**

## 5.js本身有哪些this指向
- **函数调用的时候**,`this`指向全局对象
- **对象的方法调用的时候**,`this`指向这个对象
- **构造器调用(new 调用)**,`this`指向新创建的实例对象
- **箭头函数**,`this`是自己作用域的上一层继承this

## 6.箭头函数和普通函数的区别
- 箭头函数写法比普通函数更加简洁
- **箭头函数没有自己的`this`,并且继承来的`this`不会改变**
- **箭头函数没有`prototype`(没有显示原型,但是有隐式原型__proto__)**
- 箭头函数不能用作`Generator`函数,不能使用`yield`关键字
- 箭头函数没有自己的`arguments`
- `band`、`call`、`apply`不能改变箭头函数`this`指向
### 7.箭头函数能调用band、call、apply改变this指向吗？为什么
**可以调用,但是没有效果**,原因在于,箭头函数也是函数,他的隐式原型__proto__是`Function.prototype`,在他上边会有band、call、apply方法供函数调用  
扩展:任何函数的_proto_都是Function.prototype,并且Function._proto_和Function.prototype是相等的,函数是个特殊情况,其他的不会出现自己的隐式原型和自己的显式原型一样的情况

## 8.连续调用bind的结果
多次bind输出的值是第一次bind的值  
**bind一旦this确定就不能修改**
```js
let a = 'a-window'
const o = {
  a: 'a-o'
}
const c = {
  a: 'a-c'
}
function test() {
  console.log(this.a)
}
test.bind(o).bind(c).bind(c)()//a-o
//this指向的是O,之后再多次调用bind是无效的
```
## 9.`instanceof`的实现原理
原理：如果是`a instanceof b`,会判断a的隐式原型(a.__prpto__)是否和b的显式原型(b.prototype)相等,如果不相等,会继续判断a的隐式原型的隐式原型(a.__proto__.__proto__),直到查找到a的原型链尽头,没找到则返回false
实现：利用`Object.getPrototypeOf`方法循环判断左侧实例的原型是否和右侧构造函数的prototype属性一致 
## 10.`new`关键字做了哪些事情,new的实现
- 第一步新创建一个对象
- 第二步通过使用`Object.create()`方法建立原型链继承,使新创建的对象的隐式原型(`__proto__`)指向构造函数的显式原型(`prototype`)
- 第三步通过使用`call`来执行构造函数,`this`指向这个新创建的对象,这样做可以得到构造函数内的属性和方法
- 第三步判断返回值,如果是`object`或者`function`时,返回自身的执行结果,如果不是,则返回新创建的对象
## 11.平时用到的es6相关的有哪些
模板字符串、解构、`Promise`、`let`、`const`、扩展运算符、Map和Set、类、数组`Array.form()`工厂函数、includes方法等