## 1.对于原型及原型链的理解
- 解释原型及原型链和原型链的尽头是null
- 说出隐式原型和显式原型
- 原型链的好处
  
在JS中使用构造函数来新建一个对象,这个对象的内部有一个隐式原型(`对象.__proto__`属性),这个隐式原型指向的是构造函数的显式原型对象(`构造函数.prototype`),如果这个对象是另一个构造函数的原型对象,这就形成了一种链式关系,也叫原型链,通过`__proto__`,一层一层往上寻找,在原型链的尽头是`Object.prototype.__proto__`,它指向的是`null`  

好处:如果一个属性或方法在该实例对象上没有找到的话,就会通过原型链去往上一层层去寻找,找到后就可以使用。可以做公共方法的封装,一般放在原型链上

## 2.js中有哪些继承方式,你觉得最好的继承方式是哪一种
继承方式:原型链继承、借用构造函数继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承、类继承(ES6)

最好的继承方式: 寄生组合式继承  

寄生组合继承的过程:   
主要是将寄生式继承和组合式继承组合的方式,在子类中利用`.call()`方法执行父类的方法,通过`Object.create()`方法去实现让子类的prototype等于父类prototype,同时,由于子类的原型对象发生了变化,所以,子类.prototype.constructor发生了变化,所以得再指向子类。简单来说,通过`call`方法实现父类方法和属性的继承,通过`Object.create()`实现父类原型对象的属性和方法的继承  

好处: 这样只调用了一次父构造函数,避免了子类实例和子类原型对象上生成重复的方法和属性
```js
function Parent(name) {
  this.name = name
  getItem: function() {

  }
}
Parent.prototype.getItem = function() {
  console.log(this.name)
}
function Child(name) {
  Parent.call(this,name)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```
## 3.js中改变this指向有哪些方法
bind、call、apply
### 4.这三者之间的区别
- bind、call和apply第一个参数都是要传入的`this`,当传入`null`或`undefined`时,`this`指向`window`。在参数传入的时候,bind、call传入的是多个参数,而apply传入的是数组或类数组对象
- bind返回的是一个函数并且不会被执行,而apply和call返回的是执行结果
- 当bind返回的函数作为构造函数的时候,bind时指定的`this`值会失效,但是参数依然生效,使用`new`的时候`this`指向构造出来的实例对象
- bind可以实现两次传参,调用函数的时候会把两次传参合并起来,类似于柯里化传参
利用这个特性,如果写的方法是一个通用方法,在bind时候可以把通用的一些参数传递进去,之后再别人调用这个方法的时候不用再把通用的参数传递一遍
**进大厂bind手写是关键**

## 5.js本身有哪些this指向
- **函数调用的时候**,`this`指向全局对象
- **对象的方法调用的时候**,`this`指向这个对象
- **构造器调用(new 调用)**,`this`指向新创建的实例对象
- **箭头函数**,`this`是自己作用域的上一层继承this

## 6.箭头函数和普通函数的区别
- 箭头函数写法比普通函数更加简洁
- **箭头函数没有自己的`this`,并且继承来的`this`不会改变**
- **箭头函数没有`prototype`(没有显示原型,但是有隐式原型__proto__)**
- 箭头函数不能用作`Generator`函数,不能使用`yield`关键字
- 箭头函数没有自己的`arguments`
- `band`、`call`、`apply`不能改变箭头函数`this`指向
### 7.箭头函数能调用band、call、apply改变this指向吗？为什么
**可以调用,但是没有效果**,原因在于,箭头函数也是函数,他的隐式原型__proto__是`Function.prototype`,在他上边会有band、call、apply方法供函数调用  
扩展:任何函数的_proto_都是Function.prototype,并且Function._proto_和Function.prototype是相等的,函数是个特殊情况,其他的不会出现自己的隐式原型和自己的显式原型一样的情况

## 8.连续调用bind的结果
多次bind输出的值是第一次bind的值  
**bind一旦this确定就不能修改**
```js
let a = 'a-window'
const o = {
  a: 'a-o'
}
const c = {
  a: 'a-c'
}
function test() {
  console.log(this.a)
}
test.bind(o).bind(c).bind(c)()//a-o
//this指向的是O,之后再多次调用bind是无效的
```
## 9.`instanceof`的实现原理
原理：如果是`a instanceof b`,会判断a的隐式原型(a.__prpto__)是否和b的显式原型(b.prototype)相等,如果不相等,会继续判断a的隐式原型的隐式原型(a.__proto__.__proto__),直到查找到a的原型链尽头,没找到则返回false
实现：利用`Object.getPrototypeOf`方法循环判断左侧实例的原型是否和右侧构造函数的prototype属性一致 
## 10.`new`关键字做了哪些事情,new的实现
- 第一步新创建一个对象
- 第二步通过使用`Object.create()`方法建立原型链继承,使新创建的对象的隐式原型(`__proto__`)指向构造函数的显式原型(`prototype`)
- 第三步通过使用`call`来执行构造函数,`this`指向这个新创建的对象,这样做可以得到构造函数内的属性和方法
- 第三步判断返回值,如果是`object`或者`function`时,返回自身的执行结果,如果不是,则返回新创建的对象
## 11.平时用到的es6相关的有哪些
模板字符串、解构、`Promise`、`let`、`const`、扩展运算符、Map和Set、类、数组`Array.form()`工厂函数、includes方法等
## 12.let、const和es5的var的区别
- `var`有变量提升,但是`const`和`let`没有
- `let`和`const`是块级作用域,var是全局作用域
- let和const有暂时性死区,未申明之前不可用,var没有
- 使用const必须赋初始值,let和var不用
### let用es5怎么实现
使用babel编译后,let是借助闭包或自执行函数来实现块级作用域的效果,在不同情况下let的编译结果不一样
#### 扩展: es5如何实现const
思路：利用`Object.defineProperty()`实现,由于es5环境没有block的概念,只能是挂载到某个对象下面,要么是全局window,要么是自定义一个object来当容器
```js
var _const = function _const(data, value) {
  window.data = value // 把要定义的data挂载到window下,并赋值value
  Object.defineProperty(window, data, {// 利用Object.defineProperty的能力劫持当前对象,并修改属性描述符
    enumerable: false,
    configurable: false,
    get: function () {
      return value
    }
    set: function(data) {
      if (data !== value) {//当要对当前进行赋值时,则抛出错误
        throw new TypeError('error')
      } else {
        return value
      }
    }
  })
}

_const('a',10)
console.log(a)
delete a
```
## 13.对闭包的理解
闭包其实就是一个内部函数引用了外部函数的变量,平常的做法是一个函数,在函数的内部返回一个匿名函数,这个匿名函数包含了这个函数的一些变量,这里的变量就会作为一个私有变量存储进来,之后这个函数调用结束的时候,这里的变量不会被垃圾回收机制回收,比如节流防抖。  
优点是可以定义函数私有变量,缺点是使用不当会造成内存泄漏
## 14.什么是js的垃圾回收机制？为什么闭包里的变量不会被垃圾回收机制回收？
说白了就是**定期**找出哪些不再使用的内存(变量),然后释放内存。常用的垃圾回收方式有标记清除和引用计数  
在函数执行结束后,函数外部的变量依然指向函数内部的局部变量,此时局部变量依然在被使用,所以不会回收
### 标记清除和引用计数,现代浏览器更倾向于哪一种呢
更倾向于标记清除。引用计数会引起**循环引用**问题  
一个函数内部一个对象a的一个属性引用另一个对象b,而另个一个对象b的属性引用这个对象a,在函数执行完后,a和b还将继续存在,他们的引用次数永远不会是0
```js
function fun() {
    let obj1 = {};
    let obj2 = {};
    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```
## 15.Promise的优点
平常通常用于请求的封装,解决了回调地狱的问题
`.then`具有值透传
## 16.Promise有哪些方法
- 实例方法：.then .catch .finally
- 静态方法：`Promise.all()`、`Promise.race()`、`Promise.any()`、`Promise.resolve()`、`Promise.reject()`
### Promise.all()和Promise.race()的区别
- `Promise.all()`传入的是一个`Promise`数组,如果数组里的所有状态变为成功,则返回他们的值组成的数据,如果有一个或多个是失败状态,则返回第一个失败的返回值  
- `Promise.race()`传入的也是一个数组,如果数组里有一个率先改变状态,则`Promise.race()`的状态也随之改变
#### 一个数组里想成功和失败的都返回,怎么做
使用`Promise.allSettled()`(ES2020)
## Symbol
symbol表示独一无二的值,在实现apply、call用到  
**Symbol作为属性名,遍历对象的时候,不会出现在`for...in`、`for..of`循环中,也不会被`Object.keys()、Object.getOwnPropertyNames()`、`JSON.stringify()`返回**  
可以使用`Object.getOwnPropertySymbols()`方法
## for...in和for...of区别

## 如果想判断一个数据类型到底是引用数据类型还是非引用数据类型代码怎么实现