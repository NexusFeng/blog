## 1.说说对原型及原型链的理解

- 解释原型及原型链和原型链的尽头是 null
- 说出隐式原型和显式原型
- 原型链的好处

在 JS 中使用构造函数来新建一个对象,这个对象的内部有一个隐式原型(`对象.__proto__`属性),这个隐式原型指向的是构造函数的显式原型对象(`构造函数.prototype`),如果这个对象是另一个构造函数的原型对象,这就形成了一种链式关系,也叫原型链,通过`__proto__`,一层一层往上寻找,在原型链的尽头是`Object.prototype.__proto__`,它指向的是`null`

好处:如果一个属性或方法在该实例对象上没有找到的话,就会通过原型链去往上一层层去寻找,找到后就可以使用。可以做公共方法的封装,一般放在原型链上

## 2.js 中的继承方式,最好的是哪一种?

继承方式: 原型链继承、借用构造函数继承、组合式继承、原型式继承、寄生式继承、寄生组合式继承、类继承(ES6)  
最好的继承方式: 寄生组合式继承

寄生组合式继承的过程:  
主要是将寄生式继承和组合式继承结合的方式,在子类中利用`.call`方法执行父类的方法,通过`Object.create()`方法实现让子类的 prototype 等于父类的 prototype,同时,由于子类的原型对象发生了变化,所以,子类.prototype.constructor 发生了变化,所以得再指向父类.简单来说,通过 call 方法实现父类方法和属性的继承,通过`Object.create()`实现父类原型对象的属性和方法的继承

好处: 这样就只调用了一次父构造函数,避免了子类实例和子类原型对象上生成重复的方法和属性

```js
function Parent(name) {
  this.name = name
  getItem: function(){}
}
Parent.prototype.getItem = function() {
  console.log(this.name)
}
function Child(name) {
  Parent.call(this, name)
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```

## 3.改变 this 的方式

apply、call、bind

## 4.这三者的区别

- bind、call 和 apply 第一个参数都是要传入的`this`,call 和 apply,第一个参数当传入`null`或`undefined`时,`this`指向`window`。在参数传入的时候,bind、call 传入的是多个参数,而 apply 传入的是数组或类数组对象
- bind 返回的是一个函数并且不会被执行,而 apply 和 call 返回的是执行结果
- 当 bind 返回的函数作为构造函数的时候,bind 时指定的`this`值会失效,但是参数依然生效,使用`new`的时候`this`指向构造出来的实例对象
- bind 可以实现两次传参,调用函数的时候会把两次传参合并起来,类似于柯里化传参
  利用这个特性,如果写的方法是一个通用方法,在 bind 时候可以把通用的一些参数传递进去,之后再别人调用这个方法的时候不用再把通用的参数传递一遍

## 5.如何判断数据类型

`typeof、instanceof`

## 6.如何设计一个函数,通过传入变量判断数据类型？

- 手写一个 getType 函数,传入任意变量,可准确获取类型
- 如 number string boolean 等值类型
- 还有 object array map regexp 等引用类型

```ts
// 枚举
// 缺陷: 可能会忽略某些类型
// 增加了新类型,需要修改代码
function getType(x: any): string {
  // 通过typeof 判断值类型和function
  // 其余的'object'通过instanceof 枚举
  if (typeof x === 'object') {
    if (x instanceof Array) return 'array';
    if (x instanceof Map) return 'map';
    // .....
  }
}
```

优化

```ts
// Object.prototype.toString.call()
function getType(x: any): string {
  const originType = Object.prototype.toString.call(x);
  const spaceIndex = originType.indexOf(' ');
  const type = originType.slice(spaceIndex + 1, -1);
  return type.toLowerCase();
}
```

## 7.代码输出题

- 函数参数-赋值传递

```js
function changeArg(x) {
  if (typeof x === 'object') {
    x.name = 'a';
  } else {
    x = 200;
  }
}

let num = 100;
changeArg(num);
console.log('changeA', num);
let obj = { name: 's' };
changeArg(obj);
console.log('obj', obj);
let obj1 = { city: 's' };
changeArg(obj1);
console.log('obj1', obj1);
// 100 { name: 'a' } { city: 's' }
```

## 8.对于闭包的理解

闭包其实就是一个内部函数引用了外部函数的变量,平常的做法是一个函数,在函数的内部返回一个匿名函数,这个匿名函数包含了这个函数的一些变量,这里的变量就会作为一个私有变量存储进来,之后这个函数调用结束的时候,这里的变量不会被垃圾回收机制回收,比如节流防抖。  
优点是可以定义函数私有变量,缺点是使用不当会造成内存泄漏

## 9.说说 mouseover 和 mouseenter 的区别

- 不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件(支持冒泡)。对应 mouseout
- 只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件(不支持冒泡)。对应 mouseleave
  ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a45ae95c0a3e42b286ec87504ba9aca5~tplv-k3u1fbpfcp-zoom-1.image)
