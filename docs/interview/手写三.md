### 1.节流防抖
```js
/**
 * @params fun 目标函数
 * @params wait 等待的时间
 * @params immediate 是否立即执行
 */
function debounce(fun, wait, immediate = false) {}

/**
 * @params fun 目标函数
 * @params delay 间隔的时间
 */
function throttle(fun, delay) {}

function sendAjax() {
  console.log('发送请求中...')
}

const debounceSendAjax = debounce(sendAjax, 1000)

document.addEventListener('scroll', debounceSendAjax)
```

### 2.实现 lazyMan
```js
LazyMan(“Hank”)
// Hi! This is Hank!
LazyMan(“Hank”).sleep(10).eat(“dinner”)
// Hi! This is Hank!
// 等待10秒..
// Wake up after 10
// Eat dinner~
LazyMan(“Hank”).eat(“dinner”).eat(“supper”)
// Hi This is Hank!
// Eat dinner~
// Eat supper~
LazyMan(“Hank”).sleepFirst(5).eat(“supper”)
// 等待5秒
// Wake up after 5
// Hi This is Hank!
// Eat supper
```
```js
class Lazy {
  constructor(name) {
    this.tasks = []
    this.performTasks = []
    this.name = name
    setTimeout(() => {
      this.next()
      // this.perform()
    })
  }

  // perform(){
  //   while(this.tasks.length) {
  //     this.performTasks.push(this.tasks.pop())
  //   }
  //   this.next()
  // }

  next() {
    const task = this.tasks.shift()
    // const task = this.performTasks.pop()
    if(task) task()
  }

  addStack() {
    const task = () => {
      console.log(`Hi! This is ${this.name}!`)
      this.next()
    }
    this.tasks.push(task)
    return this
  }

  eat(food) {
    const task = () => {
      console.log(`Eat ${food}`)
      this.next()
    }
    this.tasks.push(task)
    return this
  }

  sleep(second) {
    const task = () => {
      setTimeout(() => {
        console.log(`Wake up after ${second}!`)
        this.next()
      }, second*1000)
    }
    this.tasks.push(task)
    return this
  }

  sleepFirst(second) {
    const task = () => {
      setTimeout(() => {
        console.log(`Wake up after ${second}!`)
        this.next()
      }, second*1000)
    }
    this.tasks.unshift(task)
    return this
  }
}

function LazyMan(name){
  let lazyMan = new Lazy(name)
  lazyMan.addStack()
  return lazyMan
}
```
### 3.虚拟DOM转真实DOM
```js
const vnode = {
  tag: 'DIV',
  attrs: {
    id: 'app',
  },
  children: [
    {
      tag: 'SPAN',
      children: [
        {
          tag: 'A',
          children: [],
        },
      ],
    },
    {
      tag: 'SPAN',
      children: [
        {
          tag: 'A',
          children: [],
        },
        {
          tag: 'A',
          children: [],
        },
      ],
    },
  ],
}

function render(vnode) {}

// 调用 render 后将元素插入 body 下面
```
### 4.场景设计
1.设计一个 Promise.retry。
Promise.retry 作用是成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject
```js
/**
 * @params promiseFn 用户要处理的业务函数，该函数返回 Promise
 * @params times 错误时重试的次数
 */
Promise.retry = function (promiseFn, times = 3) {}
function getProm() {
  const n = Math.random()
  return new Promise((resolve, reject) => {
    setTimeout(() => (n > 0.9 ? resolve(n) : reject(n)), 1000)
  })
}
Promise.retry(getProm)
```
2.设计一个截图功能
前端实现截图的几种方案以及区别，写出伪代码
### 5.二叉树层序遍历（超高频）
```js
var levelOrder = function(root) {
  if(!root) return []
  let stacks = [[root, 0]], res = []
  while(stacks.length){
    const [stack, index] = stacks.pop()
    if(res[index]) {
      res[index].push(stack.val)
    } else {
      res[index] = [stack.val]
    }
    stack.right && stacks.push([stack.right, index+1])
    stack.left && stacks.push([stack.left, index+1])
  }
  return res
};
```