### 1.改变 this 指向
请实现 call、apply、bind
- call
```js
Function.prototype._call = function(context, ...args){
  if(!context) context = window
  let fn = Symbol()
  context[fn] = this
  let result = context[fn](...args)
  delete context[fn]
  return result
}
```
- apply
```js
Function.prototype._apply = function(context, args){
  if(!Array.isArray(args) && !(('length' in args) && typeof args.length === 'number')) {
    return throw new Error('error')
  }
  if(!context) context = window
  let fn = Symbol()
  context[fn] = this
  let result = context[fn](...args)
  delete context[fn]
  return result
}
```
- bind
```js
Function.prototype._bind = function(context, ...argArray){
  if(!context) context = window
  let fn = Symbol()
  context[fn] = this
  function proxyFn(...args){

    let finalArgs = [...argArray, ...args]
    let result = context[fn](...finalArgs)
    delete context[fn]
    return result
  }

  return proxyFn
}
```

### 2.实现函数式编程中的柯里化

```js
function curry(fn) {
   const argLen = fn.length
  // 保留预置参数
  const presetArgs = [].slice.call(arguments, 1)
  // 返回一个函数
  return function() {
    // 新函数调用时会继续传参
    const restArgs = [].slice.call(arguments)
    const allArgs = [...presetArgs, ...restArgs]
    if (allArgs.length >= argLen) {
      // 如果参数够了,就执行原函数
      return fn.apply(this, allArgs)
    } else {
      // 否则继续柯里化
      return curry.call(null, fn, ...allArgs)
    }
  }

}

function multiFn(a, b, c) {
  return a * b * c
}

var multi = curry(multiFn)

multi(2)(3)(4)
multi(2, 3, 4)
multi(2)(3, 4)
multi(2, 3)(4)

// expected output: 24
```

### 3.正则大礼包

- 实现千位分隔符

```js
// 保留三位小数
parseToMoney(1234.56) // return '1,234.56'
parseToMoney(123456789) // return '123,456,789'
parseToMoney(1087654.321) // return '1,087,654.321'
```

- 判断电话号码 (11 位的手机号)

```js
function isPhone(tel) {}
```

- 判断邮箱

```js
function isEmail(email) {}
```

- 判断身份证

```js
function isCardNo(num) {}
```

### 4.渲染十万条数据，有什么解决方案 ？

### 5.反转链表

[传送门](https://leetcode.cn/problems/reverse-linked-list/)
```js
var reverseList = function(head) {
  let p1 = null,p2 = head
  while(p2) {
    let tmp = p2.next
    p2.next = p1
    p1 = p2
    p2 = tmp
  }
  return p1
};
```