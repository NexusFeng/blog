### 2.实现 compose

实现 compose 函数, 类似于 koa 的中间件洋葱模型。

```js
// 题目需求
let middleware = []
middleware.push((next) => {
  console.log(1)
  next()
  console.log(1.1)
})
middleware.push((next) => {
  console.log(2)
  next()
  console.log(2.1)
})
middleware.push((next) => {
  console.log(3)
  next()
  console.log(3.1)
})
let fn = compose(middleware)
fn()
/*
1
2
3
3.1
2.1
1.1
*/
//实现compose函数
function compose(middlewares) {
  if(!Array.isArray(middlewares)) throw new TypeError('middleware must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError(`${fn.name} must be a function!`)
  }
  middlewares.reverse()
  return middlewares.reduce((pre,cur)=>{
    return ()=>{
      return cur(pre)
    }
  }, ()=> {})
}
```
### 3.数组转树

有以下扁平结构的数组，请转为树结构。比如：

```js
const arr = [
  {
    id: 2,
    name: '部门B',
    parentId: 0,
  },
  {
    id: 3,
    name: '部门C',
    parentId: 1,
  },
  {
    id: 1,
    name: '部门A',
    parentId: 2,
  },
  {
    id: 4,
    name: '部门D',
    parentId: 1,
  },
  {
    id: 5,
    name: '部门E',
    parentId: 2,
  },
  {
    id: 6,
    name: '部门F',
    parentId: 3,
  },
  {
    id: 7,
    name: '部门G',
    parentId: 2,
  },
  {
    id: 8,
    name: '部门H',
    parentId: 4,
  },
]
```

转为树后：

```js
const arr = [
  {
    id: 2,
    name: '部门B',
    parentId: 0,
    children: [
      {
        id: 1,
        name: '部门A',
        parentId: 2,
        children: [
          {
            id: 3,
            name: '部门C',
            parentId: 1,
            children: [
              {
                id: 6,
                name: '部门F',
                parentId: 3,
              },
            ],
          },
          {
            id: 4,
            name: '部门D',
            parentId: 1,
            children: [
              {
                id: 8,
                name: '部门H',
                parentId: 4,
              },
            ],
          },
        ],
      },
      {
        id: 5,
        name: '部门E',
        parentId: 2,
      },
      {
        id: 7,
        name: '部门G',
        parentId: 2,
      },
    ],
  },
]
```
```js
function transToTree(data){
  let res = []
  let map = {}
  if(!Array.isArray(data)) return res
  data.forEach(item => {
    map[item.id] = item
  })
  data.forEach(item => {
    let parent = map[item.parentId]
    if(parent) {
      (parent.children || parent.children=[]).push(item)
      res.push(item)
    }
  })
  return res
}
```
### 4.场景：前端的权限系统怎么实现？

假如某个系统有超级管理员，平台管理员、运营管理、会员、游客等角色，不同的角色进入系统后可以操作的页面不同，包括：

- 操作按钮
- 路由页面
- 页面内容不同

请问该如何设计？

- 位运算判断
```js
let superAdmin = 1
let platformAdmin = 1 << 1
let vip = 1 << 2

// 授权
let user = superAdmin | platformAdmin

// 鉴权
console.log(user & superAdmin) // 1
console.log(user & platformAdmin) // 1
console.log(user & vip) // 0

// 删除权限
user = user^platformAdmin
```
### 5.无重复字符的最大子串
```js
var lengthOfLongestSubstring = function(s) {
  let len = 0
  if(!s.length) return len
  let set = new Set()
  let i = 0,j=0
  while(i < s.length){
    if(set.has(s[i])) {
      j++
      len = Math.max(len, set.size)
      set.clear()
      i = j
    }
    set.add(s[i])
    i++
  }
  len = Math.max(len, set.size)// 防止'aab'
  return len
};
```