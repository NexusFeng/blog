---
title: 2.响应式数据原理
---
## 核心
**数据驱动视图变化**
## 基本原理
- 对象通过`Object.defineProperty`进行`get、set`拦截
- 数组通过重写数组的七中修改方法完成对数组的监听
- 采用观察者模式实现依赖收集和派发更新
## 数据初始化
```js
new Vue({
  el: "#app",
  router,
  store,
  render: h => h(App)
})
```
vue其实就是一个构造函数,在实例化过程中,对数据进行初始化,initMixin把``_init`方法挂载到Vue原型上供Vue调用
```js
// src/core/instance/index.js
...
function Vue (options) { //vue构造函数
  this._init(options)
}

initMixin(Vue) // Vue.prototype._init
...
export default Vue
```
`_init`方法会对一些声明周期等做初始化,其中就包括初始化状态
```js
// /src/core/instance/init.js
export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    const vm = this
    ...
    // 初始化状态
    initState(vm)
    ...
  }
}
```
在`initState`方法中,就包括了一些对`prop、methods、data`等的初始化,初始化的顺序为`prop -> methods -> data -> computed -> watch`,在初始化data时,就会对data里的数据进行代理
```js
// src/core/instance/state.js
export function initState (vm) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm) //数据处理
  } else {
    observe(vm._data = {}, true)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}

function initData (vm) {
  let data = vm.$options.data
  // 定义私有变量_data
  data = vm._data = typeof data === 'function'? getData(data, vm): data || {}
  // proxy data on instance
  // 循环判断,props和methods定义的变量不能和data里定义的变量相同,因为他们最后都会挂载到vue实例vm上
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      //代理,将data挂载到vue实例vm上
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```
## 对对象的数据劫持
在初始化数据时,会对数据进行劫持,如果是对象类型才能被检测,同时在Observer类中,会声明一个`__ob__`(通过修改属性描述符来标记数据不会被枚举)属性用来标记数据是否被监听过,如果监听过就不再进行监听。  
```js
// /src/core/observer/index.js
export class Observer {
  constructor (value) {
    this.value = value
    this.dep = new Dep()  //给每个对象创建一个dep
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods) // __proto__
      } else {
        copyAugment(value, arrayMethods, arrayKeys) //循环每一项赋值
      }
      this.observeArray(value) //观测数组每一项
    } else {
      this.walk(value)
    }
  }

  walk (obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

...

export function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) { //如果是虚拟节点也不用观测
    return
  }
  let ob
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) && //isExtensible表示可以被defineProperty
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
...

```
通过`defineReactive`方法对对象**不断的进行递归进行劫持**,利用`Object.defineProperty`中的`getter`和`setter`对数据进行拦截
```js
// /src/core/observer/index.js
export function defineReactive (obj,key,val,customSetter,shallow) {
  const dep = new Dep()
  // 在data定义的对象中,可自定义getter和setter
  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) { // 可配置才能加defineProperty
    return
  }
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      //vm.a = 1 => vm.a = [1,2,3]
      childOb = !shallow && observe(newVal) //当赋值一个新值时 需要重新监控 并且更新childOb
      dep.notify()
    }
  })
}
```
## 对数组的数据劫持
初始化`Observer`类和对对象的递归劫持过程中会判断数据是否为数据,如果是数组会通过对数组方法的劫持来监听数组(切片编程),也会递归对数组中不是基本数据类型的数据进行观测  
只有这七种方法会改变数组,所以Vue对这七种方法进行了重写,目的是**对新增的内容进行观测,同时派发更新**
```js
// /src/core/observer/array.js
import { def } from '../util/index'
const arrayProto = Array.prototype
// 继承数组方法, 保留原有数组功能
export const arrayMethods = Object.create(arrayProto)
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    ob.dep.notify()
    return result
  })
})
```
## 依赖收集

## 派发更新

## 注意点
- 由于利用`Object.defineProperty`递归对对象进行观测,所以对象的层级过深会导致性能受影响
- 此时的观测是基于`data`定义的对象属性(`observe(data)初始化之后执行,之后不再执行`),如果后期给对象新增/删除属性时,Vue是拦截不到的,也就是说不是响应式的,只有对象本身就存在的属性修改才会被劫持。
- 可以使用`$set`让对象自己去`notify`,用户对对象属性赋值新对象,vue会对这个对象进行观测
- 通过数组索引修改数组或者改变数组长度,是不会触发更新的,通过7种重写的方法更新视图
- 数组重写的7种方法`push、shift、unshift、pop、reverse、sort、splice`

## 总结
