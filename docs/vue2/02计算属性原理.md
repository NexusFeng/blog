---
title: 3.计算属性原理
---
## 计算属性的初始化
计算属性可以写成一个函数形式,也可以写成对象形式,但对象形式必须要有`get`方法
```js
// /src/core/instance/state.js
function initComputed (vm: Component, computed: Object) {
  // 定义缓存watcher的值
  const watchers = vm._computedWatchers = Object.create(null)
  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    // 判断key是否在vm上定义过
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
    ...
    }
    if (!isSSR) {
      // 将每个属性初始化watcher
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,//回调函数
       computedWatcherOptions
      )
    }
  }
}

export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 判断是不是ssr
  const shouldCache = !isServerRendering()
  //当计算属性为方法时,定义get方法
  if (typeof userDef === 'function') {
    // 重写get方法
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    // 获取对象时的get方法
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }
  
  // 将计算属性放到vm上并对计算属性的get和set做劫持
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

// 重写计算属性的get方法,判断是否需要重新计算
function createComputedGetter (key) {
  return function computedGetter () {
    // 获取计算属性watcher
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // 如果是脏的,需要重新求值
      if (watcher.dirty) {
        watcher.evaluate()
      }
      // 如果dep还存在target,这时候一般为渲染watcher,计算属性依赖的数据也需要收集
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```
## watcher中计算属性相关
重点两个变量`lazy:表示是否为计算属性,计算属性初始化时默认值为true`和`dirty:表示是否为脏数据,如果为脏数据,需要重新计算,计算属性初始化时默认值为true`
```js
export default class Watcher {
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    vm._watchers.push(this) //为了能强制更新
    // options
    if (options) {
      this.user = !!options.user
      this.lazy = !!options.lazy// 标识计算属性watcher
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.active = true
    this.dirty = this.lazy // 表示watcher是否需要重新计算,默认为true
    this.deps = []
    this.newDeps = []
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      // 如果是'a.b.c':{},去解析key
      this.getter = parsePath(expOrFn)
    }
    // 非计算属性实例化会默认调用get方法进行取值,计算属性的实例化时候不会去调用get
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      // 计算属性在这里执行用户定义的get函数,访问计算属性依赖项 从而把自身计算watcher添加到依赖项dep里面收集起来
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps() //不清理 可能上次的数据还要被再次收集 vm.a = [1,2,3] => vm.a = {}数组不需要在收集
    }
    return value
  }

  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  update () {
    // 计算属性的依赖值发生了变化,只需要把dirty设置为true,下次访问到了就重新计算
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      // 异步队列机制
      queueWatcher(this)
    }
  }

  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        const oldValue = this.value
        this.value = value
        if (this.user) {
          const info = `callback for watcher "${this.expression}"`
          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info)
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
  // 获取值,并把dirty设置为false,表示已经计算过值
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  depend () {
    // 计算属性的watcher储存了依赖项的dep
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()//调用依赖项的dep去收集watcher
    }
  }
}
```
## 注意点
- 计算属性可以是一个函数,也可以是对象,当为对象时,必须设置`get`函数
