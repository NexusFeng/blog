---
title: 6.初始渲染及更新原理原理
---

## 组件挂载入口
compiler版会将only版的`$mount`方法先缓存起来,扩展完功能后再调用,compiler版将`template`转化成render函数就会执行`mountComponent`方法挂载组件
```js
// /core/platforms/web/runtime/index.js
Vue.prototype.$mount = function ( //公共的$mount
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating) //组件挂载
}

// /core/platforms/web/entry-runtime-with-compiler.js
//缓存mount方法
const mount = Vue.prototype.$mount
// 做扩展
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  ...
  // 调用组件挂载方法
  return mount.call(this, el, hydrating) 
}
```
## 组件挂载的方法
```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // 对el做缓存
  vm.$el = el
  
  callHook(vm, 'beforeMount') //beforeMount生命周期函数

  let updateComponent
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }
  new Watcher(vm, updateComponent, noop, {
    before () { //更新钩子
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false //不是服务端渲染
  if (vm.$vnode == null) {
    vm._isMounted = true //已经渲染过了
    callHook(vm, 'mounted')//当前组件挂载完毕
  }
  return vm
}
```