---
title: 9.异步更新原理
---

## 定义
`nextTick`定义的有两处地方,所以可以通过`Vue.nextTick`和`this.$nextTick`两种方式调用
```js
// src/core/global-api/index.js
Vue.nextTick = nextTick
// src/core/instance/render.js
Vue.prototype.$nextTick = function (fn: Function) {
  return nextTick(fn, this)
}
```

## `nextTick`实现
首先是`嗅探环境`,依次检测`Promise.then`->`MutationObserver`->`setImmediate`->`setTimeout`,依次去找,如果存在就使用它来异步执行
```js
// src/core/util/next-tick.js
export let isUsingMicroTask = false
// 存放异步调用任务
const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  // 循环执行队列中的任务
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}
// 嗅探环境
let timerFunc
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}

export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      // 为了保证队列中有出错的任务不会影响到其他任务执行,故采用try...catch的形式
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  // 确保其中的逻辑只执行一次
  if (!pending) {
    pending = true
    timerFunc()
  }
  // 如果有Promise,则nextTick支持then写法  this.$nextTick().then()
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}

```
## 总结
`nextTick`是把要执行的任务推入到一个队列中,在下一个tick同步执行,数据改变后触发渲染watcher的update,但是watcher的flush是在nextTick后,所以重新渲染是异步的