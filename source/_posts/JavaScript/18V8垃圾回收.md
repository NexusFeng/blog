---
title: V8垃圾回收
date: 2022-02-12
categories: 
  - JavaScript
tags: 
  - JavaScript
---

## 前置

- GC: 垃圾回收机制(一般的高级语言会自带 GC,如 Java、python、js 等,c/c++不自带)
- js 垃圾回收机制说白了就是**定期**找出哪些不再使用的内存(变量),然后释放内存
- 算法策略:  
  **标记清除法**
  - 标记:为所有活动对象做上标记
  - 清除:把所有没有标记的(非活动对象)清除
  - 缺点: 内存碎片化、分配速度慢
  - 基于两个缺点,标记整理算法可有效的解决  
    **引用计数法**
  - 跟踪记录每个变量值被使用的次数
  - 缺点: 需要计数器,计数器占很大内存、无法解决循环引用无法回收问题

## V8 对 GC 的优化

### 分代式垃圾回收

v8 的垃圾回收策略主要基于分代式垃圾回收机制,v8 中将堆内存分为新生代和老生代,采用不同的垃圾回收器管理垃圾回收

- 新生代 (存活时间较短的对象)
  ![新生代](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a428ca00cb164eeab16e8cbbb603e7d7~tplv-k3u1fbpfcp-watermark.awebp)

新生代垃圾回收通过 Cheney 算法将堆内存一分为二,一个使用中的空间称为使用区,处于闲置的空间称为空闲区。当使用区快写满时,就需要执行一次垃圾回收操作  
当开始进行垃圾回收时,新生代的垃圾回收器会对使用区的活动对象进行标记并复制进空闲区排序储存,最后进行垃圾清理,完成后进行两个区角色互换。  
当一个对象复制多次后依然存在,则移入老生代中

- 老生代 (存活时间较长或者常驻内存的对象)
  对于大多数占用空间大、存活时间长的对象会被分配到老生代里,采用的标记清除清理垃圾

### 并行回收

全停顿: js 是单线程,需等垃圾回收完之后再恢复脚本执行
并行: 垃圾回收器在主线程上执行的过程中,开启多个辅助线程同时执行同样的工作
![并行回收](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0eef6c0d3bd49659a564fe698d17f43~tplv-k3u1fbpfcp-watermark.awebp)

## 造成内存泄漏的操作

- 由于使用未声明的变量,而意外的创建了一个全局变量,而使这个变量一直留在内存中无法被回收。
- 设置了 setInterval 定时器,而忘记取消它,如果循环函数有对外部变量的引用的话,那么这个变量会被一直留在内存中,而无法被回收。
- 获取一个 DOM 元素的引用,而后面这个元素被删除,由于我们一直保留了对这个元素的引用,所以它也无法被回收。
- 不合理的使用闭包,从而导致某些变量一直被留在内存当中。

## 脑图

![GC](/images/JavaScript/GC.jpg)
